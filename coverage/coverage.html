
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/antenore/deecli/cmd/analyze.go (0.0%)</option>
				
				<option value="file1">github.com/antenore/deecli/cmd/chat.go (0.0%)</option>
				
				<option value="file2">github.com/antenore/deecli/cmd/config.go (0.0%)</option>
				
				<option value="file3">github.com/antenore/deecli/cmd/explain.go (0.0%)</option>
				
				<option value="file4">github.com/antenore/deecli/cmd/improve.go (0.0%)</option>
				
				<option value="file5">github.com/antenore/deecli/cmd/root.go (0.0%)</option>
				
				<option value="file6">github.com/antenore/deecli/internal/ai/operations.go (0.0%)</option>
				
				<option value="file7">github.com/antenore/deecli/internal/api/client.go (35.0%)</option>
				
				<option value="file8">github.com/antenore/deecli/internal/api/deepseek.go (0.0%)</option>
				
				<option value="file9">github.com/antenore/deecli/internal/api/service.go (0.0%)</option>
				
				<option value="file10">github.com/antenore/deecli/internal/api/types.go (0.0%)</option>
				
				<option value="file11">github.com/antenore/deecli/internal/chat/app.go (0.0%)</option>
				
				<option value="file12">github.com/antenore/deecli/internal/chat/commands/ai_commands.go (25.0%)</option>
				
				<option value="file13">github.com/antenore/deecli/internal/chat/commands/config_commands.go (31.8%)</option>
				
				<option value="file14">github.com/antenore/deecli/internal/chat/commands/file_commands.go (0.0%)</option>
				
				<option value="file15">github.com/antenore/deecli/internal/chat/commands/handler.go (0.0%)</option>
				
				<option value="file16">github.com/antenore/deecli/internal/chat/commands/system_commands.go (0.0%)</option>
				
				<option value="file17">github.com/antenore/deecli/internal/chat/completion.go (21.2%)</option>
				
				<option value="file18">github.com/antenore/deecli/internal/chat/input/manager.go (60.7%)</option>
				
				<option value="file19">github.com/antenore/deecli/internal/chat/keydetect/detector.go (0.0%)</option>
				
				<option value="file20">github.com/antenore/deecli/internal/chat/model.go (21.0%)</option>
				
				<option value="file21">github.com/antenore/deecli/internal/chat/tracker/filetracker.go (88.4%)</option>
				
				<option value="file22">github.com/antenore/deecli/internal/chat/ui/layout.go (0.0%)</option>
				
				<option value="file23">github.com/antenore/deecli/internal/chat/ui/renderer.go (0.0%)</option>
				
				<option value="file24">github.com/antenore/deecli/internal/chat/ui/sidebar.go (0.0%)</option>
				
				<option value="file25">github.com/antenore/deecli/internal/chat/viewport/manager.go (0.0%)</option>
				
				<option value="file26">github.com/antenore/deecli/internal/config/config.go (0.0%)</option>
				
				<option value="file27">github.com/antenore/deecli/internal/editor/editor.go (0.0%)</option>
				
				<option value="file28">github.com/antenore/deecli/internal/files/context.go (0.0%)</option>
				
				<option value="file29">github.com/antenore/deecli/internal/files/loader.go (0.0%)</option>
				
				<option value="file30">github.com/antenore/deecli/internal/history/manager.go (0.0%)</option>
				
				<option value="file31">github.com/antenore/deecli/internal/sessions/loader.go (0.0%)</option>
				
				<option value="file32">github.com/antenore/deecli/internal/sessions/session.go (0.0%)</option>
				
				<option value="file33">github.com/antenore/deecli/internal/utils/terminal.go (0.0%)</option>
				
				<option value="file34">github.com/antenore/deecli/internal/utils/text.go (0.0%)</option>
				
				<option value="file35">github.com/antenore/deecli/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/antenore/deecli/internal/api"
        "github.com/antenore/deecli/internal/files"
)

// analyzeCmd represents the analyze command
var analyzeCmd = &amp;cobra.Command{
        Use:   "analyze &lt;file&gt;",
        Short: "Analyze a code file and get suggestions",
        Long: `Analyze a code file and get AI-powered suggestions for improvements,
potential issues, and best practices.`,
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                filepath := args[0]
                
                // Check if API key is available
                cfg := configManager.Get()
                if cfg.APIKey == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå No API key found. Please run 'deecli config init' or set DEEPSEEK_API_KEY environment variable.\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("üîç Analyzing %s...\n", filepath)
                
                // Load the file
                loader := files.NewFileLoader()
                fileInfo, err := loader.LoadFile(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Failed to load file: %v\n", err)
                        os.Exit(1)
                }</span>
                
                // Create API service
                <span class="cov0" title="0">service := api.NewDeepSeekService(cfg.APIKey, cfg.Model, cfg.Temperature, cfg.MaxTokens)
                
                // Analyze the code
                analysis, err := service.AnalyzeCode(fileInfo.Content, fileInfo.RelPath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Analysis failed: %v\n", err)
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("\nüìä Analysis of %s:\n\n%s\n", fileInfo.RelPath, analysis)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(analyzeCmd)
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
        "github.com/antenore/deecli/internal/chat"
        "github.com/spf13/cobra"
)

var continueSession bool

// chatCmd represents the chat command
var chatCmd = &amp;cobra.Command{
        Use:   "chat",
        Short: "Start interactive coding chat session",
        Long: `Start an interactive chat session with DeepSeek AI for discussing code,
getting explanations, and iterative development assistance.

Features:
- File loading with glob pattern support
- Command history and completion  
- Session persistence
- Professional TUI with Bubbletea`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Use configuration values
                chatApp := chat.NewChatApp()
                if continueSession </span><span class="cov0" title="0">{
                        if err := chatApp.StartContinueWithConfig(configManager, apiKey, model, temperature, maxTokens); err != nil </span><span class="cov0" title="0">{
                                cmd.PrintErrf("Chat error: %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := chatApp.StartNewWithConfig(configManager, apiKey, model, temperature, maxTokens); err != nil </span><span class="cov0" title="0">{
                                cmd.PrintErrf("Chat error: %v\n", err)
                        }</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(chatCmd)
        chatCmd.Flags().BoolVar(&amp;continueSession, "continue", false, "Continue previous chat session")
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
        "bufio"
        "fmt"
        "os"
        "strings"
        "syscall"

        "github.com/antenore/deecli/internal/config"
        "github.com/spf13/cobra"
        "golang.org/x/term"
)

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Manage DeeCLI configuration",
        Long:  `Initialize and manage DeeCLI configuration including API keys and model settings.`,
}

var configInitCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize DeeCLI configuration",
        Long:  `Set up your DeeCLI configuration with API key and default settings.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigInit()
        }</span>,
}

var configShowCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Show current configuration",
        Long:  `Display the current merged configuration from all sources.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigShow()
        }</span>,
}

var configSetCmd = &amp;cobra.Command{
        Use:   "set &lt;key&gt; &lt;value&gt;",
        Short: "Set a configuration value",
        Long:  `Set a configuration value. Valid keys: api-key, model, temperature, max-tokens`,
        Args:  cobra.ExactArgs(2),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigSet(args[0], args[1])
        }</span>,
}

var configModelCmd = &amp;cobra.Command{
        Use:   "model &lt;model&gt;",
        Short: "Set the default model",
        Long:  `Set the default model to use for API requests.`,
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigSet("model", args[0])
        }</span>,
}

var configEditorCmd = &amp;cobra.Command{
        Use:   "editor &lt;editor&gt;",
        Short: "Set the default editor",
        Long:  `Set the default editor for file editing operations.`,
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigSet("editor", args[0])
        }</span>,
}

var configTempCmd = &amp;cobra.Command{
        Use:   "temperature &lt;value&gt;",
        Short: "Set the temperature value",
        Long:  `Set the temperature value for API requests (0.0-1.0).`,
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigSet("temperature", args[0])
        }</span>,
}

var configTokensCmd = &amp;cobra.Command{
        Use:   "max-tokens &lt;value&gt;",
        Short: "Set the max tokens value",
        Long:  `Set the maximum tokens for API requests.`,
        Args:  cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                return runConfigSet("max-tokens", args[0])
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(configCmd)
        configCmd.AddCommand(configInitCmd)
        configCmd.AddCommand(configShowCmd)
        configCmd.AddCommand(configSetCmd)
        configCmd.AddCommand(configModelCmd)
        configCmd.AddCommand(configEditorCmd)
        configCmd.AddCommand(configTempCmd)
        configCmd.AddCommand(configTokensCmd)
}</span>

func runConfigInit() error <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        
        // Check if config already exists
        if configManager.GlobalConfigExists() </span><span class="cov0" title="0">{
                fmt.Print("Global configuration already exists. Overwrite? (y/N): ")
                response, _ := reader.ReadString('\n')
                response = strings.TrimSpace(strings.ToLower(response))
                if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                        fmt.Println("Configuration unchanged.")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("üîß DeeCLI Configuration Setup")
        fmt.Println("=============================")
        fmt.Println()

        // Get API key
        fmt.Print("Enter your DeepSeek API key: ")
        bytePassword, err := term.ReadPassword(int(syscall.Stdin))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read API key: %w", err)
        }</span>
        <span class="cov0" title="0">apiKeyInput := strings.TrimSpace(string(bytePassword))
        fmt.Println() // New line after password input

        if apiKeyInput == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("API key cannot be empty")
        }</span>

        // Get model preference
        <span class="cov0" title="0">fmt.Printf("Select model (default: deepseek-chat): ")
        modelInput, _ := reader.ReadString('\n')
        modelInput = strings.TrimSpace(modelInput)
        if modelInput == "" </span><span class="cov0" title="0">{
                modelInput = "deepseek-chat"
        }</span>

        // Get temperature
        <span class="cov0" title="0">fmt.Printf("Temperature (0.0-1.0, default: 0.1): ")
        tempInput, _ := reader.ReadString('\n')
        tempInput = strings.TrimSpace(tempInput)
        tempValue := 0.1
        if tempInput != "" </span><span class="cov0" title="0">{
                fmt.Sscanf(tempInput, "%f", &amp;tempValue)
        }</span>

        // Get max tokens
        <span class="cov0" title="0">fmt.Printf("Max tokens (default: 2048): ")
        tokensInput, _ := reader.ReadString('\n')
        tokensInput = strings.TrimSpace(tokensInput)
        tokensValue := 2048
        if tokensInput != "" </span><span class="cov0" title="0">{
                fmt.Sscanf(tokensInput, "%d", &amp;tokensValue)
        }</span>

        // Save configuration
        <span class="cov0" title="0">cfg := &amp;config.Config{
                APIKey:      apiKeyInput,
                Model:       modelInput,
                Temperature: tempValue,
                MaxTokens:   tokensValue,
                Profiles:    make(map[string]config.Profile),
        }

        if err := configManager.SaveGlobal(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("‚úÖ Configuration saved successfully!")
        fmt.Printf("   Location: ~/.deecli/config.yaml\n")
        fmt.Println()
        fmt.Println("You can now use DeeCLI without setting environment variables.")
        fmt.Println("To create project-specific settings, run 'deecli config init' in your project directory.")

        return nil</span>
}

func runConfigShow() error <span class="cov0" title="0">{
        // Reload config to get latest
        if err := configManager.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">cfg := configManager.Get()

        fmt.Println("üìã Current Configuration")
        fmt.Println("========================")
        fmt.Println()
        
        // Show config sources
        if configManager.GlobalConfigExists() </span><span class="cov0" title="0">{
                fmt.Println("‚úì Global config: ~/.deecli/config.yaml")
        }</span>
        <span class="cov0" title="0">if configManager.ProjectConfigExists() </span><span class="cov0" title="0">{
                fmt.Println("‚úì Project config: ./.deecli/config.yaml")
        }</span>
        <span class="cov0" title="0">if os.Getenv("DEEPSEEK_API_KEY") != "" </span><span class="cov0" title="0">{
                fmt.Println("‚úì Environment: DEEPSEEK_API_KEY")
        }</span>
        
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("Merged Configuration:")
        fmt.Println("--------------------")
        
        // Hide API key for security
        apiKeyDisplay := cfg.APIKey
        if len(apiKeyDisplay) &gt; 8 </span><span class="cov0" title="0">{
                apiKeyDisplay = apiKeyDisplay[:4] + "..." + apiKeyDisplay[len(apiKeyDisplay)-4:]
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("API Key:      %s\n", apiKeyDisplay)
        fmt.Printf("Model:        %s\n", cfg.Model)
        fmt.Printf("Temperature:  %.2f\n", cfg.Temperature)
        fmt.Printf("Max Tokens:   %d\n", cfg.MaxTokens)
        
        if cfg.ActiveProfile != "" </span><span class="cov0" title="0">{
                fmt.Printf("Active Profile: %s\n", cfg.ActiveProfile)
        }</span>
        
        <span class="cov0" title="0">if len(cfg.Profiles) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nProfiles:")
                for name := range cfg.Profiles </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s\n", name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runConfigSet(key, value string) error <span class="cov0" title="0">{
        // Load current config
        if err := configManager.Load(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">cfg := configManager.Get()
        
        // Create a copy to modify
        newCfg := *cfg
        
        switch key </span>{
        case "api-key":<span class="cov0" title="0">
                newCfg.APIKey = value
                fmt.Printf("‚úÖ API key updated (showing first 4 characters: %s...)\n", value[:min(4, len(value))])</span>
        case "model":<span class="cov0" title="0">
                newCfg.Model = value
                fmt.Printf("‚úÖ Model set to: %s\n", value)</span>
        case "temperature":<span class="cov0" title="0">
                var temp float64
                if _, err := fmt.Sscanf(value, "%f", &amp;temp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid temperature value: %s", value)
                }</span>
                <span class="cov0" title="0">if temp &lt; 0.0 || temp &gt; 1.0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("temperature must be between 0.0 and 1.0")
                }</span>
                <span class="cov0" title="0">newCfg.Temperature = temp
                fmt.Printf("‚úÖ Temperature set to: %.2f\n", temp)</span>
        case "max-tokens":<span class="cov0" title="0">
                var tokens int
                if _, err := fmt.Sscanf(value, "%d", &amp;tokens); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid max-tokens value: %s", value)
                }</span>
                <span class="cov0" title="0">if tokens &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("max-tokens must be positive")
                }</span>
                <span class="cov0" title="0">newCfg.MaxTokens = tokens
                fmt.Printf("‚úÖ Max tokens set to: %d\n", tokens)</span>
        case "editor":<span class="cov0" title="0">
                // For now, we'll just acknowledge the editor setting
                // In future, this could be stored in a separate editor config field
                fmt.Printf("‚úÖ Default editor preference noted: %s\n", value)
                fmt.Println("   (Editor integration will use this preference in future versions)")
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown config key: %s. Valid keys: api-key, model, temperature, max-tokens, editor", key)</span>
        }

        // Determine where to save
        <span class="cov0" title="0">if configManager.ProjectConfigExists() </span><span class="cov0" title="0">{
                if err := configManager.SaveProject(&amp;newCfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save project configuration: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("   Saved to project config: ./.deecli/config.yaml")</span>
        } else<span class="cov0" title="0"> if configManager.GlobalConfigExists() </span><span class="cov0" title="0">{
                if err := configManager.SaveGlobal(&amp;newCfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save global configuration: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("   Saved to global config: ~/.deecli/config.yaml")</span>
        } else<span class="cov0" title="0"> {
                if err := configManager.SaveGlobal(&amp;newCfg); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save global configuration: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("   Created global config: ~/.deecli/config.yaml")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/antenore/deecli/internal/api"
        "github.com/antenore/deecli/internal/files"
)

// explainCmd represents the explain command
var explainCmd = &amp;cobra.Command{
        Use:   "explain &lt;file&gt;",
        Short: "Get code explanation",
        Long: `Analyze a code file and get a detailed explanation of what it does,
how it works, and its key components.`,
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                filepath := args[0]
                
                // Check if API key is available
                cfg := configManager.Get()
                if cfg.APIKey == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå No API key found. Please run 'deecli config init' or set DEEPSEEK_API_KEY environment variable.\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("üìñ Analyzing %s for explanation...\n", filepath)
                
                // Load the file
                loader := files.NewFileLoader()
                fileInfo, err := loader.LoadFile(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Failed to load file: %v\n", err)
                        os.Exit(1)
                }</span>
                
                // Create API service
                <span class="cov0" title="0">service := api.NewDeepSeekService(cfg.APIKey, cfg.Model, cfg.Temperature, cfg.MaxTokens)
                
                // Get code explanation
                explanation, err := service.ExplainCode(fileInfo.Content, fileInfo.RelPath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Analysis failed: %v\n", err)
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("\nüìö Explanation of %s:\n\n%s\n", fileInfo.RelPath, explanation)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(explainCmd)
}</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/antenore/deecli/internal/api"
        "github.com/antenore/deecli/internal/files"
)

// improveCmd represents the improve command
var improveCmd = &amp;cobra.Command{
        Use:   "improve &lt;file&gt;",
        Short: "Get code improvement suggestions",
        Long: `Analyze a code file and get AI-powered suggestions for improvements,
refactoring opportunities, and best practices.`,
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                filepath := args[0]
                
                // Check if API key is available
                cfg := configManager.Get()
                if cfg.APIKey == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå No API key found. Please run 'deecli config init' or set DEEPSEEK_API_KEY environment variable.\n")
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("üí° Analyzing %s for improvements...\n", filepath)
                
                // Load the file
                loader := files.NewFileLoader()
                fileInfo, err := loader.LoadFile(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Failed to load file: %v\n", err)
                        os.Exit(1)
                }</span>
                
                // Create API service
                <span class="cov0" title="0">service := api.NewDeepSeekService(cfg.APIKey, cfg.Model, cfg.Temperature, cfg.MaxTokens)
                
                // Get improvement suggestions
                suggestions, err := service.ImproveCode(fileInfo.Content, fileInfo.RelPath)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ùå Analysis failed: %v\n", err)
                        os.Exit(1)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("\nüöÄ Improvement suggestions for %s:\n\n%s\n", fileInfo.RelPath, suggestions)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(improveCmd)
}</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/antenore/deecli/internal/config"
)

var (
        // Config flags
        apiKey      string
        model       string
        temperature float64
        maxTokens   int
        verbose     bool
        quiet       bool

        // Config manager
        configManager *config.Manager
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "deecli",
        Short: "üêâ AI-powered code assistant using DeepSeek models",
        Long: `DeeCLI is a professional AI-powered code assistant using DeepSeek models,
focusing on excellent terminal UX, session persistence, and extensibility.

Built with Go, Cobra, and Bubbletea for maximum performance and reliability.`,
        Version: "0.1.0",
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;apiKey, "api-key", "", "DeepSeek API key (overrides config)")
        rootCmd.PersistentFlags().StringVar(&amp;model, "model", "", "Model to use (overrides config)")
        rootCmd.PersistentFlags().Float64Var(&amp;temperature, "temperature", 0, "Temperature for generation (overrides config)")
        rootCmd.PersistentFlags().IntVar(&amp;maxTokens, "max-tokens", 0, "Maximum tokens to generate (overrides config)")
        rootCmd.PersistentFlags().BoolVar(&amp;verbose, "verbose", false, "Enable verbose output")
        rootCmd.PersistentFlags().BoolVar(&amp;quiet, "quiet", false, "Quiet mode")

        // Hide help command since we have custom help
        rootCmd.SetHelpCommand(&amp;cobra.Command{
                Use:    "no-help",
                Hidden: true,
        })
}</span>

func initConfig() <span class="cov0" title="0">{
        configManager = config.NewManager()
        
        // Load configuration files
        if err := configManager.Load(); err != nil </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: Failed to load config: %v\n", err)
                }</span>
        }

        // Apply command-line overrides
        <span class="cov0" title="0">cfg := configManager.Get()
        
        // Command-line flags take precedence
        if apiKey != "" </span><span class="cov0" title="0">{
                cfg.APIKey = apiKey
        }</span>
        <span class="cov0" title="0">if model != "" </span><span class="cov0" title="0">{
                cfg.Model = model
        }</span>
        <span class="cov0" title="0">if temperature != 0 </span><span class="cov0" title="0">{
                cfg.Temperature = temperature
        }</span>
        <span class="cov0" title="0">if maxTokens != 0 </span><span class="cov0" title="0">{
                cfg.MaxTokens = maxTokens
        }</span>

        // Update the flag values with config values if not set
        <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = cfg.APIKey
        }</span>
        <span class="cov0" title="0">if model == "" </span><span class="cov0" title="0">{
                model = cfg.Model
        }</span>
        <span class="cov0" title="0">if temperature == 0 </span><span class="cov0" title="0">{
                temperature = cfg.Temperature
        }</span>
        <span class="cov0" title="0">if maxTokens == 0 </span><span class="cov0" title="0">{
                maxTokens = cfg.MaxTokens
        }</span>

        // Check if API key is set when needed
        <span class="cov0" title="0">if !isConfigCommand() &amp;&amp; apiKey == "" &amp;&amp; !configManager.GlobalConfigExists() </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "‚ùå No API key found. Please run 'deecli config init' or set DEEPSEEK_API_KEY environment variable.")
                os.Exit(1)
        }</span>
}

func isConfigCommand() bool <span class="cov0" title="0">{
        // Check if the command is a config command (we'll implement this command next)
        args := os.Args[1:]
        return len(args) &gt; 0 &amp;&amp; args[0] == "config"
}</pre>
		
		<pre class="file" id="file6" style="display: none">package ai

import (
        "context"
        "fmt"
        "io"
        "strings"

        "github.com/antenore/deecli/internal/api"
        "github.com/antenore/deecli/internal/files"

        tea "github.com/charmbracelet/bubbletea"
)

// APIResponseMsg for async API calls
type APIResponseMsg struct {
        Response string
        Err      error
}

// StreamChunkMsg represents a chunk of streaming response
type StreamChunkMsg struct {
        Content string
        IsDone  bool
        Err     error
}

// StreamCompleteMsg signals the end of a streaming response
type StreamCompleteMsg struct {
        TotalContent string
        Err          error
}

// Operations handles AI-related operations
type Operations struct {
        apiClient    *api.Service
        apiMessages  []api.Message
        apiCancel    context.CancelFunc
        fileContext  *files.FileContext
}

// NewOperations creates a new Operations instance
func NewOperations(apiClient *api.Service, fileContext *files.FileContext) *Operations <span class="cov0" title="0">{
        return &amp;Operations{
                apiClient:   apiClient,
                apiMessages: []api.Message{},
                fileContext: fileContext,
        }
}</span>

// GetAPIMessages returns the current API messages
func (o *Operations) GetAPIMessages() []api.Message <span class="cov0" title="0">{
        return o.apiMessages
}</span>

// SetAPIMessages sets the API messages
func (o *Operations) SetAPIMessages(messages []api.Message) <span class="cov0" title="0">{
        o.apiMessages = messages
}</span>

// GetAPICancel returns the current API cancel function
func (o *Operations) GetAPICancel() context.CancelFunc <span class="cov0" title="0">{
        return o.apiCancel
}</span>

// SetAPICancel sets the API cancel function
func (o *Operations) SetAPICancel(cancel context.CancelFunc) <span class="cov0" title="0">{
        o.apiCancel = cancel
}</span>

// CallAPI makes an API call with context and user input
func (o *Operations) CallAPI(contextPrompt, userInput string) tea.Cmd <span class="cov0" title="0">{
        // Create a context that can be cancelled
        ctx, cancel := context.WithCancel(context.Background())

        // Store the cancel function so we can use it later
        o.apiCancel = cancel

        return func() tea.Msg </span><span class="cov0" title="0">{
                // Use the new ChatWithHistory method to include conversation context
                response, err := o.apiClient.ChatWithHistoryContext(ctx, o.apiMessages, contextPrompt, userInput)
                return APIResponseMsg{Response: response, Err: err}
        }</span>
}

// CallAPIStream makes a streaming API call with context and user input
// It returns a command that starts the streaming process
func (o *Operations) CallAPIStream(contextPrompt, userInput string) tea.Cmd <span class="cov0" title="0">{
        // Create a context that can be cancelled
        ctx, cancel := context.WithCancel(context.Background())

        // Store the cancel function so we can use it later
        o.apiCancel = cancel

        return func() tea.Msg </span><span class="cov0" title="0">{
                stream, err := o.apiClient.ChatWithHistoryContextStream(ctx, o.apiMessages, contextPrompt, userInput)
                if err != nil </span><span class="cov0" title="0">{
                        return StreamCompleteMsg{Err: err}
                }</span>

                // Return a StreamReader wrapper that the model can use
                <span class="cov0" title="0">return StreamStartedMsg{
                        Stream: stream,
                        Ctx:    ctx,
                }</span>
        }
}

// StreamStartedMsg indicates that streaming has started
type StreamStartedMsg struct {
        Stream api.StreamReader
        Ctx    context.Context
}

// ReadNextChunk returns a command to read the next chunk from a stream
func ReadNextChunk(stream api.StreamReader, accumulated string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                chunk, err := stream.Recv()
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                // Stream completed successfully
                                stream.Close()
                                return StreamCompleteMsg{TotalContent: accumulated}
                        }</span>
                        // Stream error
                        <span class="cov0" title="0">stream.Close()
                        return StreamCompleteMsg{TotalContent: accumulated, Err: err}</span>
                }

                // Extract content from chunk
                <span class="cov0" title="0">content := ""
                if len(chunk.Choices) &gt; 0 </span><span class="cov0" title="0">{
                        content = chunk.Choices[0].Delta.Content
                }</span>

                <span class="cov0" title="0">return StreamChunkMsg{
                        Content: content,
                        IsDone:  false,
                }</span>
        }
}

// AnalyzeFiles analyzes loaded files
func (o *Operations) AnalyzeFiles() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(o.fileContext.Files) == 0 </span><span class="cov0" title="0">{
                        return APIResponseMsg{Err: fmt.Errorf("no files loaded")}
                }</span>

                <span class="cov0" title="0">var allAnalysis strings.Builder
                for _, file := range o.fileContext.Files </span><span class="cov0" title="0">{
                        analysis, err := o.apiClient.AnalyzeCode(file.Content, file.RelPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return APIResponseMsg{Err: fmt.Errorf("error analyzing %s: %w", file.RelPath, err)}
                        }</span>
                        <span class="cov0" title="0">allAnalysis.WriteString(fmt.Sprintf("Analysis of %s:\n\n%s\n\n", file.RelPath, analysis))</span>
                }

                <span class="cov0" title="0">return APIResponseMsg{Response: allAnalysis.String()}</span>
        }
}

// ExplainFiles explains loaded files
func (o *Operations) ExplainFiles() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(o.fileContext.Files) == 0 </span><span class="cov0" title="0">{
                        return APIResponseMsg{Err: fmt.Errorf("no files loaded")}
                }</span>

                <span class="cov0" title="0">var allExplanations strings.Builder
                for _, file := range o.fileContext.Files </span><span class="cov0" title="0">{
                        explanation, err := o.apiClient.ExplainCode(file.Content, file.RelPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return APIResponseMsg{Err: fmt.Errorf("error explaining %s: %w", file.RelPath, err)}
                        }</span>
                        <span class="cov0" title="0">allExplanations.WriteString(fmt.Sprintf("Explanation of %s:\n\n%s\n\n", file.RelPath, explanation))</span>
                }

                <span class="cov0" title="0">return APIResponseMsg{Response: allExplanations.String()}</span>
        }
}

// ImproveFiles suggests improvements for loaded files
func (o *Operations) ImproveFiles() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                if len(o.fileContext.Files) == 0 </span><span class="cov0" title="0">{
                        return APIResponseMsg{Err: fmt.Errorf("no files loaded")}
                }</span>

                <span class="cov0" title="0">var allImprovements strings.Builder
                for _, file := range o.fileContext.Files </span><span class="cov0" title="0">{
                        improvements, err := o.apiClient.ImproveCode(file.Content, file.RelPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return APIResponseMsg{Err: fmt.Errorf("error improving %s: %w", file.RelPath, err)}
                        }</span>
                        <span class="cov0" title="0">allImprovements.WriteString(fmt.Sprintf("Improvement suggestions for %s:\n\n%s\n\n", file.RelPath, improvements))</span>
                }

                <span class="cov0" title="0">return APIResponseMsg{Response: allImprovements.String()}</span>
        }
}

// GenerateEditSuggestions suggests edits based on conversation history
func (o *Operations) GenerateEditSuggestions() tea.Cmd <span class="cov0" title="0">{
        // Create a context that can be cancelled
        ctx, cancel := context.WithCancel(context.Background())

        // Store the cancel function
        o.apiCancel = cancel

        return func() tea.Msg </span><span class="cov0" title="0">{
                // Build prompt for AI to analyze conversation and suggest file edits
                var promptBuilder strings.Builder
                promptBuilder.WriteString("You are an expert software engineer reviewing a conversation with a developer. ")
                promptBuilder.WriteString("Based on the conversation history and the loaded files, suggest specific files that should be edited and what changes should be made.\n\n")

                // Add loaded files context
                promptBuilder.WriteString("## Loaded Files:\n")
                for _, file := range o.fileContext.Files </span><span class="cov0" title="0">{
                        promptBuilder.WriteString(fmt.Sprintf("**%s** (%s, %d bytes)\n", file.RelPath, file.Language, file.Size))
                }</span>
                <span class="cov0" title="0">promptBuilder.WriteString("\n")

                // Add conversation context (last 10 messages for relevance)
                promptBuilder.WriteString("## Recent Conversation:\n")
                startIdx := 0
                if len(o.apiMessages) &gt; 10 </span><span class="cov0" title="0">{
                        startIdx = len(o.apiMessages) - 10
                }</span>
                <span class="cov0" title="0">for i := startIdx; i &lt; len(o.apiMessages); i++ </span><span class="cov0" title="0">{
                        msg := o.apiMessages[i]
                        promptBuilder.WriteString(fmt.Sprintf("**%s**: %s\n", strings.Title(msg.Role), msg.Content))
                }</span>

                <span class="cov0" title="0">promptBuilder.WriteString("\n## Your Task:\n")
                promptBuilder.WriteString("Analyze the conversation and suggest specific files that need editing based on:\n")
                promptBuilder.WriteString("1. Issues or bugs mentioned\n")
                promptBuilder.WriteString("2. Feature requests or improvements discussed\n")
                promptBuilder.WriteString("3. Code quality concerns raised\n")
                promptBuilder.WriteString("4. Missing functionality identified\n\n")
                promptBuilder.WriteString("Format your response as:\n")
                promptBuilder.WriteString("**üìù Edit Suggestions:**\n")
                promptBuilder.WriteString("‚Ä¢ **filename.ext** - Brief description of what changes are needed\n")
                promptBuilder.WriteString("‚Ä¢ **another.file** - Another change description\n\n")
                promptBuilder.WriteString("If no specific changes are needed, suggest general improvements or say 'No specific edits needed based on current conversation'.")

                // Create messages for API call
                messages := []api.Message{
                        {
                                Role:    "system",
                                Content: "You are an expert software engineer and code reviewer who analyzes conversations to suggest targeted file modifications.",
                        },
                        {
                                Role:    "user",
                                Content: promptBuilder.String(),
                        },
                }

                // Call API with context for cancellation
                response, err := o.apiClient.ChatWithHistoryContext(ctx, messages, "", "")
                return APIResponseMsg{Response: response, Err: err}</span>
        }
}</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "math"
        "net/http"
        "strings"
        "sync"
        "time"
)

// DeepSeekClient handles low-level HTTP communication with DeepSeek API
type DeepSeekClient struct {
        apiKey      string
        baseURL     string
        model       string
        temperature float64
        maxTokens   int
        httpClient  *http.Client
        maxRetries  int
        baseDelay   time.Duration

        // Connection management
        lastActivity time.Time
        activityMu   sync.Mutex
        transport    *http.Transport
        ctx          context.Context
        cancel       context.CancelFunc
}

// NewDeepSeekClient creates a new DeepSeek API client
func NewDeepSeekClient(apiKey, model string, temperature float64, maxTokens int) *DeepSeekClient <span class="cov0" title="0">{
        transport := &amp;http.Transport{
                MaxIdleConns:        10,               // Maximum idle connections to keep
                MaxIdleConnsPerHost: 10,               // Maximum idle connections per host
                IdleConnTimeout:     90 * time.Second, // How long to keep idle connections
                TLSHandshakeTimeout: 10 * time.Second,
        }

        ctx, cancel := context.WithCancel(context.Background())

        client := &amp;DeepSeekClient{
                apiKey:      apiKey,
                baseURL:     "https://api.deepseek.com",
                model:       model,
                temperature: temperature,
                maxTokens:   maxTokens,
                httpClient: &amp;http.Client{
                        Timeout:   120 * time.Second,
                        Transport: transport,
                },
                maxRetries:   3,
                baseDelay:    time.Second,
                lastActivity: time.Now(),
                transport:    transport,
                ctx:          ctx,
                cancel:       cancel,
        }

        // Start connection manager goroutine
        go client.manageConnection()

        return client
}</span>

// SendChatRequest sends a chat completion request
func (client *DeepSeekClient) SendChatRequest(ctx context.Context, messages []Message) (string, error) <span class="cov0" title="0">{
        return client.sendChatRequestWithRetryContext(ctx, messages)
}</span>

// sendChatRequestWithRetryContext sends a chat request with retry logic and context cancellation
func (client *DeepSeekClient) sendChatRequestWithRetryContext(ctx context.Context, messages []Message) (string, error) <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt;= client.maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Exponential backoff with jitter
                        delay := time.Duration(float64(client.baseDelay) * math.Pow(2, float64(attempt-1)))
                        if delay &gt; 30*time.Second </span><span class="cov0" title="0">{
                                delay = 30 * time.Second
                        }</span>
                        <span class="cov0" title="0">time.Sleep(delay)</span>
                }

                // Check if context was cancelled before making request
                <span class="cov0" title="0">if ctx.Err() == context.Canceled </span><span class="cov0" title="0">{
                        return "", APIError{
                                StatusCode:  0,
                                Message:     "request cancelled by user",
                                Retryable:   false,
                                UserMessage: "Request cancelled",
                        }
                }</span>

                <span class="cov0" title="0">result, err := client.sendSingleRequestWithContext(ctx, messages)
                if err == nil </span><span class="cov0" title="0">{
                        return result, nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // Check if error is retryable
                if apiErr, ok := err.(APIError); ok &amp;&amp; !apiErr.Retryable </span><span class="cov0" title="0">{
                        return "", apiErr
                }</span>

                // Don't retry on the last attempt
                <span class="cov0" title="0">if attempt == client.maxRetries </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed after %d attempts: %w", client.maxRetries+1, lastErr)</span>
}

// sendSingleRequestWithContext makes a single API request with context support for cancellation
func (client *DeepSeekClient) sendSingleRequestWithContext(ctx context.Context, messages []Message) (string, error) <span class="cov0" title="0">{
        // Update activity timestamp
        client.updateActivity()

        // DeepSeek reasoner model doesn't support temperature parameter
        request := ChatRequest{
                Model:     client.model,
                Messages:  messages,
                MaxTokens: client.maxTokens,
        }

        // Only add temperature for non-reasoner models
        if client.model != "deepseek-reasoner" </span><span class="cov0" title="0">{
                request.Temperature = client.temperature
        }</span>

        <span class="cov0" title="0">jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", APIError{
                        StatusCode:  0,
                        Message:     fmt.Sprintf("failed to marshal request: %v", err),
                        Retryable:   false,
                        UserMessage: "Request formatting error. Please try again.",
                }
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", client.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", APIError{
                        StatusCode:  0,
                        Message:     fmt.Sprintf("failed to create request: %v", err),
                        Retryable:   false,
                        UserMessage: "Request creation error. Please try again.",
                }
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+client.apiKey)

        resp, err := client.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // Check if context was cancelled
                if ctx.Err() == context.Canceled </span><span class="cov0" title="0">{
                        return "", APIError{
                                StatusCode:  0,
                                Message:     "request cancelled by user",
                                Retryable:   false,
                                UserMessage: "Request cancelled",
                        }
                }</span>
                // Network errors are generally retryable
                <span class="cov0" title="0">return "", APIError{
                        StatusCode:  0,
                        Message:     fmt.Sprintf("request failed: %v", err),
                        Retryable:   true,
                        UserMessage: "Network error. Retrying...",
                }</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", APIError{
                        StatusCode:  resp.StatusCode,
                        Message:     fmt.Sprintf("failed to read response: %v", err),
                        Retryable:   true,
                        UserMessage: "Error reading response. Retrying...",
                }
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", client.handleHTTPError(resp.StatusCode, body)
        }</span>

        <span class="cov0" title="0">var response ChatResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return "", APIError{
                        StatusCode:  resp.StatusCode,
                        Message:     fmt.Sprintf("failed to unmarshal response: %v", err),
                        Retryable:   true,
                        UserMessage: "Error parsing response. Retrying...",
                }
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", APIError{
                        StatusCode:  resp.StatusCode,
                        Message:     "no response choices received",
                        Retryable:   true,
                        UserMessage: "Empty response received. Retrying...",
                }
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}

// handleHTTPError provides user-friendly error messages for HTTP errors
func (client *DeepSeekClient) handleHTTPError(statusCode int, body []byte) APIError <span class="cov8" title="1">{
        bodyStr := string(body)

        switch statusCode </span>{
        case 400:<span class="cov0" title="0">
                return APIError{
                        StatusCode:  statusCode,
                        Message:     fmt.Sprintf("bad request: %s", bodyStr),
                        Retryable:   false,
                        UserMessage: "Invalid request. Please check your input and try again.",
                }</span>
        case 401:<span class="cov8" title="1">
                return APIError{
                        StatusCode:  statusCode,
                        Message:     fmt.Sprintf("unauthorized: %s", bodyStr),
                        Retryable:   false,
                        UserMessage: "API key is invalid or missing. Please set DEEPSEEK_API_KEY environment variable.",
                }</span>
        case 403:<span class="cov0" title="0">
                return APIError{
                        StatusCode:  statusCode,
                        Message:     fmt.Sprintf("forbidden: %s", bodyStr),
                        Retryable:   false,
                        UserMessage: "Access denied. Please check your API key permissions.",
                }</span>
        case 429:<span class="cov8" title="1">
                return APIError{
                        StatusCode:  statusCode,
                        Message:     fmt.Sprintf("rate limited: %s", bodyStr),
                        Retryable:   true,
                        UserMessage: "Rate limit exceeded. Retrying with backoff...",
                }</span>
        case 500, 502, 503, 504:<span class="cov8" title="1">
                return APIError{
                        StatusCode:  statusCode,
                        Message:     fmt.Sprintf("server error (%d): %s", statusCode, bodyStr),
                        Retryable:   true,
                        UserMessage: "Server error. Retrying...",
                }</span>
        default:<span class="cov0" title="0">
                return APIError{
                        StatusCode:  statusCode,
                        Message:     fmt.Sprintf("API error (%d): %s", statusCode, bodyStr),
                        Retryable:   statusCode &gt;= 500,
                        UserMessage: fmt.Sprintf("API error (status %d). Please try again.", statusCode),
                }</span>
        }
}

// WarmUp performs an initial connection to pre-establish TLS handshake
func (client *DeepSeekClient) WarmUp() error <span class="cov0" title="0">{
        // Send a minimal request to establish connection
        warmupMsg := []Message{
                {Role: "system", Content: "ping"},
                {Role: "user", Content: "pong"},
        }

        // Store original values
        origMaxTokens := client.maxTokens
        client.maxTokens = 1 // Minimal response

        // Perform warm-up request
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        _, err := client.sendSingleRequestWithContext(ctx, warmupMsg)

        // Restore original values
        client.maxTokens = origMaxTokens

        if err != nil </span><span class="cov0" title="0">{
                // Don't fail if warm-up fails, just log it
                return fmt.Errorf("connection warm-up failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// manageConnection monitors activity and closes idle connections
func (client *DeepSeekClient) manageConnection() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second) // Check every 30 seconds
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        client.activityMu.Lock()
                        inactiveTime := time.Since(client.lastActivity)
                        client.activityMu.Unlock()

                        // Close connections after 10 minutes of inactivity
                        if inactiveTime &gt; 10*time.Minute </span><span class="cov0" title="0">{
                                client.transport.CloseIdleConnections()
                        }</span>

                case &lt;-client.ctx.Done():<span class="cov0" title="0">
                        // Clean shutdown
                        client.transport.CloseIdleConnections()
                        return</span>
                }
        }
}

// updateActivity updates the last activity timestamp
func (client *DeepSeekClient) updateActivity() <span class="cov8" title="1">{
        client.activityMu.Lock()
        client.lastActivity = time.Now()
        client.activityMu.Unlock()
}</span>

// Close gracefully shuts down the client and closes connections
func (client *DeepSeekClient) Close() <span class="cov0" title="0">{
        if client.cancel != nil </span><span class="cov0" title="0">{
                client.cancel()
        }</span>
        <span class="cov0" title="0">if client.transport != nil </span><span class="cov0" title="0">{
                client.transport.CloseIdleConnections()
        }</span>
}

// deepSeekStreamReader implements StreamReader interface
type deepSeekStreamReader struct {
        reader  *bufio.Reader
        resp    *http.Response
        ctx     context.Context
}

// Recv reads the next chunk from the stream
func (s *deepSeekStreamReader) Recv() (ChatCompletionChunk, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                // Check context cancellation
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        return ChatCompletionChunk{}, s.ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">line, err := s.reader.ReadBytes('\n')
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return ChatCompletionChunk{}, io.EOF
                        }</span>
                        <span class="cov8" title="1">return ChatCompletionChunk{}, err</span>
                }

                <span class="cov8" title="1">lineStr := strings.TrimSpace(string(line))

                // Skip empty lines
                if lineStr == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Skip SSE comments (keep-alive)
                <span class="cov8" title="1">if strings.HasPrefix(lineStr, ":") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for data prefix
                <span class="cov8" title="1">if !strings.HasPrefix(lineStr, "data: ") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract data
                <span class="cov8" title="1">data := strings.TrimPrefix(lineStr, "data: ")

                // Check for stream end
                if data == "[DONE]" </span><span class="cov8" title="1">{
                        return ChatCompletionChunk{}, io.EOF
                }</span>

                // Parse JSON chunk
                <span class="cov8" title="1">var chunk ChatCompletionChunk
                if err := json.Unmarshal([]byte(data), &amp;chunk); err != nil </span><span class="cov0" title="0">{
                        // Skip malformed chunks
                        continue</span>
                }

                <span class="cov8" title="1">return chunk, nil</span>
        }
}

// Close closes the stream reader
func (s *deepSeekStreamReader) Close() error <span class="cov8" title="1">{
        if s.resp != nil &amp;&amp; s.resp.Body != nil </span><span class="cov8" title="1">{
                return s.resp.Body.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SendChatRequestStream sends a streaming chat completion request
func (client *DeepSeekClient) SendChatRequestStream(ctx context.Context, messages []Message) (StreamReader, error) <span class="cov8" title="1">{
        // Update activity timestamp
        client.updateActivity()

        // Create streaming request
        request := StreamingChatRequest{
                Model:     client.model,
                Messages:  messages,
                MaxTokens: client.maxTokens,
                Stream:    true,
        }

        // Only add temperature for non-reasoner models
        if client.model != "deepseek-reasoner" </span><span class="cov8" title="1">{
                request.Temperature = client.temperature
        }</span>

        <span class="cov8" title="1">jsonData, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, APIError{
                        StatusCode:  0,
                        Message:     fmt.Sprintf("failed to marshal request: %v", err),
                        Retryable:   false,
                        UserMessage: "Request formatting error. Please try again.",
                }
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", client.baseURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, APIError{
                        StatusCode:  0,
                        Message:     fmt.Sprintf("failed to create request: %v", err),
                        Retryable:   false,
                        UserMessage: "Request creation error. Please try again.",
                }
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+client.apiKey)
        req.Header.Set("Accept", "text/event-stream")
        req.Header.Set("Cache-Control", "no-cache")
        req.Header.Set("Connection", "keep-alive")

        resp, err := client.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // Check if context was cancelled
                if ctx.Err() == context.Canceled </span><span class="cov0" title="0">{
                        return nil, APIError{
                                StatusCode:  0,
                                Message:     "request cancelled by user",
                                Retryable:   false,
                                UserMessage: "Request cancelled",
                        }
                }</span>
                <span class="cov0" title="0">return nil, APIError{
                        StatusCode:  0,
                        Message:     fmt.Sprintf("request failed: %v", err),
                        Retryable:   true,
                        UserMessage: "Network error. Please try again.",
                }</span>
        }

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                defer resp.Body.Close()
                body, _ := io.ReadAll(resp.Body)
                return nil, client.handleHTTPError(resp.StatusCode, body)
        }</span>

        // Create stream reader
        <span class="cov8" title="1">reader := &amp;deepSeekStreamReader{
                reader: bufio.NewReader(resp.Body),
                resp:   resp,
                ctx:    ctx,
        }

        return reader, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api


// NewDeepSeekService creates a new DeepSeek service with client and service layer
func NewDeepSeekService(apiKey, model string, temperature float64, maxTokens int) *Service <span class="cov0" title="0">{
        client := NewDeepSeekClient(apiKey, model, temperature, maxTokens)
        return NewService(client)
}</span>


</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

import (
        "context"
        "fmt"
        "strings"

        "github.com/antenore/deecli/internal/files"
)

// Service provides high-level AI operations using the underlying client
type Service struct {
        client *DeepSeekClient
}

// NewService creates a new AI service with the provided client
func NewService(client *DeepSeekClient) *Service <span class="cov0" title="0">{
        return &amp;Service{client: client}
}</span>

// ChatAboutCode sends a chat request about code to the AI
func (s *Service) ChatAboutCode(code, userMessage string) (string, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert software engineer and code reviewer.
You help developers understand, improve, and debug their code.
Provide clear, actionable advice and explanations.`,
                },
        }

        var userContent string
        if code != "" </span><span class="cov0" title="0">{
                userContent = fmt.Sprintf("%s\n\n%s", code, userMessage)
        }</span> else<span class="cov0" title="0"> {
                userContent = userMessage
        }</span>

        <span class="cov0" title="0">messages = append(messages, Message{
                Role:    "user",
                Content: userContent,
        })

        return s.client.SendChatRequest(context.Background(), messages)</span>
}

// ChatWithHistory sends a chat request with conversation history and code context
func (s *Service) ChatWithHistory(conversationHistory []Message, contextPrompt, userMessage string) (string, error) <span class="cov0" title="0">{
        return s.ChatWithHistoryContext(context.Background(), conversationHistory, contextPrompt, userMessage)
}</span>

// ChatWithHistoryContext sends a chat request with conversation history and code context, with cancellation support
func (s *Service) ChatWithHistoryContext(ctx context.Context, conversationHistory []Message, contextPrompt, userMessage string) (string, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert software engineer and code reviewer.
You help developers understand, improve, and debug their code.
Provide clear, actionable advice and explanations.`,
                },
        }

        messages = append(messages, conversationHistory...)

        var userContent string
        if contextPrompt != "" </span><span class="cov0" title="0">{
                userContent = fmt.Sprintf("%s\n\n%s", contextPrompt, userMessage)
        }</span> else<span class="cov0" title="0"> {
                userContent = userMessage
        }</span>

        <span class="cov0" title="0">messages = append(messages, Message{
                Role:    "user",
                Content: userContent,
        })

        return s.client.SendChatRequest(ctx, messages)</span>
}

// AnalyzeCode analyzes code and provides suggestions
func (s *Service) AnalyzeCode(code, filename string) (string, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert code analyzer. Analyze the provided code and give:
1. Code quality assessment
2. Potential issues or bugs
3. Performance considerations
4. Best practice recommendations
5. Security concerns if any`,
                },
                {
                        Role:    "user",
                        Content: fmt.Sprintf("Please analyze this code from %s:\n\n```\n%s\n```", filename, code),
                },
        }

        return s.client.SendChatRequest(context.Background(), messages)
}</span>

// ImproveCode suggests improvements for the given code
func (s *Service) ImproveCode(code, filename string) (string, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert software engineer. Suggest improvements for the provided code:
1. Code optimization opportunities
2. Better algorithms or data structures
3. Improved readability and maintainability
4. Modern language features that could be used
5. Error handling improvements`,
                },
                {
                        Role:    "user",
                        Content: fmt.Sprintf("Please suggest improvements for this code from %s:\n\n```\n%s\n```", filename, code),
                },
        }

        return s.client.SendChatRequest(context.Background(), messages)
}</span>

// ExplainCode explains what the code does
func (s *Service) ExplainCode(code, filename string) (string, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert code explainer. Explain the provided code clearly:
1. What the code does overall
2. Key functions and their purposes
3. Important algorithms or logic
4. Dependencies and external interactions
5. Use cases and examples`,
                },
                {
                        Role:    "user",
                        Content: fmt.Sprintf("Please explain this code from %s:\n\n```\n%s\n```", filename, code),
                },
        }

        return s.client.SendChatRequest(context.Background(), messages)
}</span>

// GenerateEditSuggestions analyzes conversation context and suggests which files to edit
func (s *Service) GenerateEditSuggestions(ctx context.Context, conversationHistory []Message, fileContext *files.FileContext) (string, error) <span class="cov0" title="0">{
        var contextBuilder strings.Builder
        contextBuilder.WriteString("=== LOADED FILES ===\n")

        for _, file := range fileContext.Files </span><span class="cov0" title="0">{
                contextBuilder.WriteString(fmt.Sprintf("File: %s (%s)\n", file.RelPath, file.Language))
                contextBuilder.WriteString(fmt.Sprintf("Size: %d bytes\n", file.Size))
                contextBuilder.WriteString("Content preview:\n")
                contextBuilder.WriteString(file.Content[:min(len(file.Content), 500)])
                if len(file.Content) &gt; 500 </span><span class="cov0" title="0">{
                        contextBuilder.WriteString("...")
                }</span>
                <span class="cov0" title="0">contextBuilder.WriteString("\n\n")</span>
        }

        <span class="cov0" title="0">contextBuilder.WriteString("\n=== CONVERSATION HISTORY ===\n")
        for _, msg := range conversationHistory </span><span class="cov0" title="0">{
                contextBuilder.WriteString(fmt.Sprintf("%s: %s\n", msg.Role, msg.Content))
        }</span>

        <span class="cov0" title="0">messages := []Message{
                {
                        Role: "system",
                        Content: `You are an AI assistant helping identify which files need to be edited based on a conversation.

Analyze the conversation history and loaded files, then suggest:
1. Which specific files should be modified
2. What type of changes are needed for each file
3. Priority order for making the changes
4. Brief explanation of why each file needs changes

Format your response as:
## Files to Edit

### High Priority
- **filename.ext**: Brief description of changes needed

### Medium Priority
- **filename.ext**: Brief description of changes needed

### Low Priority
- **filename.ext**: Brief description of changes needed

## Recommendations
Brief explanation of the suggested approach and order.`,
                },
                {
                        Role:    "user",
                        Content: fmt.Sprintf("Based on this context, suggest which files should be edited:\n\n%s", contextBuilder.String()),
                },
        }

        return s.client.SendChatRequest(ctx, messages)</span>
}

// min helper function
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// ChatAboutCodeStream sends a streaming chat request about code to the AI
func (s *Service) ChatAboutCodeStream(ctx context.Context, code, userMessage string) (StreamReader, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert software engineer and code reviewer.
You help developers understand, improve, and debug their code.
Provide clear, actionable advice and explanations.`,
                },
        }

        var userContent string
        if code != "" </span><span class="cov0" title="0">{
                userContent = fmt.Sprintf("%s\n\n%s", code, userMessage)
        }</span> else<span class="cov0" title="0"> {
                userContent = userMessage
        }</span>

        <span class="cov0" title="0">messages = append(messages, Message{
                Role:    "user",
                Content: userContent,
        })

        return s.client.SendChatRequestStream(ctx, messages)</span>
}

// ChatWithHistoryContextStream sends a streaming chat request with conversation history and code context
func (s *Service) ChatWithHistoryContextStream(ctx context.Context, conversationHistory []Message, contextPrompt, userMessage string) (StreamReader, error) <span class="cov0" title="0">{
        messages := []Message{
                {
                        Role: "system",
                        Content: `You are an expert software engineer and code reviewer.
You help developers understand, improve, and debug their code.
Provide clear, actionable advice and explanations.`,
                },
        }

        messages = append(messages, conversationHistory...)

        var userContent string
        if contextPrompt != "" </span><span class="cov0" title="0">{
                userContent = fmt.Sprintf("%s\n\n%s", contextPrompt, userMessage)
        }</span> else<span class="cov0" title="0"> {
                userContent = userMessage
        }</span>

        <span class="cov0" title="0">messages = append(messages, Message{
                Role:    "user",
                Content: userContent,
        })

        return s.client.SendChatRequestStream(ctx, messages)</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

// ChatRequest represents a chat completion request
type ChatRequest struct {
        Model       string    `json:"model"`
        Messages    []Message `json:"messages"`
        Temperature float64   `json:"temperature,omitempty"`
        MaxTokens   int       `json:"max_tokens"`
}

// Message represents a chat message
type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// ChatResponse represents the API response
type ChatResponse struct {
        ID      string `json:"id"`
        Object  string `json:"object"`
        Created int64  `json:"created"`
        Model   string `json:"model"`
        Choices []struct {
                Index   int `json:"index"`
                Message struct {
                        Role    string `json:"role"`
                        Content string `json:"content"`
                } `json:"message"`
                FinishReason string `json:"finish_reason"`
        } `json:"choices"`
        Usage struct {
                PromptTokens     int `json:"prompt_tokens"`
                CompletionTokens int `json:"completion_tokens"`
                TotalTokens      int `json:"total_tokens"`
        } `json:"usage"`
}

// StreamingChatRequest represents a streaming chat completion request
type StreamingChatRequest struct {
        Model       string    `json:"model"`
        Messages    []Message `json:"messages"`
        Temperature float64   `json:"temperature,omitempty"`
        MaxTokens   int       `json:"max_tokens"`
        Stream      bool      `json:"stream"`
}

// ChatCompletionChunk represents a chunk in streaming response
type ChatCompletionChunk struct {
        ID      string `json:"id"`
        Object  string `json:"object"`
        Created int64  `json:"created"`
        Model   string `json:"model"`
        Choices []struct {
                Index int `json:"index"`
                Delta struct {
                        Role    string `json:"role,omitempty"`
                        Content string `json:"content,omitempty"`
                } `json:"delta"`
                FinishReason *string `json:"finish_reason"`
        } `json:"choices"`
        Usage *struct {
                PromptTokens     int `json:"prompt_tokens"`
                CompletionTokens int `json:"completion_tokens"`
                TotalTokens      int `json:"total_tokens"`
        } `json:"usage,omitempty"`
}

// StreamReader represents a streaming response reader
type StreamReader interface {
        Recv() (ChatCompletionChunk, error)
        Close() error
}

// APIError represents enhanced API error information
type APIError struct {
        StatusCode  int
        Message     string
        Retryable   bool
        UserMessage string
}

func (e APIError) Error() string <span class="cov0" title="0">{
        return e.Message
}</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package chat

import (
        "fmt"
        "github.com/antenore/deecli/internal/config"
        tea "github.com/charmbracelet/bubbletea"
)

// ChatApp represents the main chat application
type ChatApp struct {
        program *tea.Program
}

// NewChatApp creates a new chat application
func NewChatApp() *ChatApp <span class="cov0" title="0">{
        return &amp;ChatApp{}
}</span>

// Start initializes and starts the chat application (legacy method)
func (app *ChatApp) Start() error <span class="cov0" title="0">{
        m := newChatModel()
        
        // Try with alt screen first, fallback to normal mode if TTY issues
        app.program = tea.NewProgram(m, tea.WithAltScreen())
        
        if _, err := app.program.Run(); err != nil </span><span class="cov0" title="0">{
                // Fallback to basic mode without alt screen
                fmt.Println("Falling back to basic mode...")
                app.program = tea.NewProgram(m)
                _, err = app.program.Run()
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// StartNew initializes and starts the new chat application
func (app *ChatApp) StartNew() error <span class="cov0" title="0">{
        m := newChatModel()
        
        // Use alt screen for full terminal control with proper input handling
        app.program = tea.NewProgram(m, 
                tea.WithAltScreen(),
        )
        
        if _, err := app.program.Run(); err != nil </span><span class="cov0" title="0">{
                // Fallback to basic mode without alt screen
                fmt.Println("Falling back to basic mode...")
                app.program = tea.NewProgram(m)
                _, err = app.program.Run()
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// StartNewWithConfig initializes and starts the chat application with specific configuration
func (app *ChatApp) StartNewWithConfig(configManager *config.Manager, apiKey, model string, temperature float64, maxTokens int) error <span class="cov0" title="0">{
        m := newChatModelWithConfig(configManager, apiKey, model, temperature, maxTokens)
        
        // Use alt screen for full terminal control with proper input handling
        app.program = tea.NewProgram(m, 
                tea.WithAltScreen(),
        )
        
        if _, err := app.program.Run(); err != nil </span><span class="cov0" title="0">{
                // Fallback to basic mode without alt screen
                fmt.Println("Falling back to basic mode...")
                app.program = tea.NewProgram(m)
                _, err = app.program.Run()
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// StartContinueWithConfig continues previous session with specific configuration
func (app *ChatApp) StartContinueWithConfig(configManager *config.Manager, apiKey, model string, temperature float64, maxTokens int) error <span class="cov0" title="0">{
        m := newChatModelWithConfig(configManager, apiKey, model, temperature, maxTokens)
        
        // Load previous session messages
        if err := m.loadPreviousSession(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Could not load previous session: %v\n", err)
                fmt.Println("Starting new session instead...")
        }</span>
        
        // Use alt screen for full terminal control with proper input handling
        <span class="cov0" title="0">app.program = tea.NewProgram(m, 
                tea.WithAltScreen(),
        )
        
        if _, err := app.program.Run(); err != nil </span><span class="cov0" title="0">{
                // Fallback to basic mode without alt screen
                fmt.Println("Falling back to basic mode...")
                app.program = tea.NewProgram(m)
                _, err = app.program.Run()
                return err
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/antenore/deecli/internal/editor"
        tea "github.com/charmbracelet/bubbletea"
)

// AICommands handles AI-related chat commands
type AICommands struct {
        deps Dependencies
}

// NewAICommands creates a new AI commands handler
func NewAICommands(deps Dependencies) *AICommands <span class="cov0" title="0">{
        return &amp;AICommands{deps: deps}
}</span>

// Analyze handles the /analyze command
func (ai *AICommands) Analyze(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(ai.deps.FileContext.Files) == 0 </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "No files loaded. Use /load to load files first.")
                return nil
        }</span>

        <span class="cov0" title="0">if ai.deps.APIClient == nil </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "Please set DEEPSEEK_API_KEY environment variable")
                return nil
        }</span>

        <span class="cov0" title="0">ai.deps.SetLoading(true, "Analyzing files...")
        ai.deps.RefreshUI()
        return ai.deps.AnalyzeFiles()</span>
}

// Explain handles the /explain command
func (ai *AICommands) Explain(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(ai.deps.FileContext.Files) == 0 </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "No files loaded. Use /load to load files first.")
                return nil
        }</span>

        <span class="cov0" title="0">if ai.deps.APIClient == nil </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "Please set DEEPSEEK_API_KEY environment variable")
                return nil
        }</span>

        <span class="cov0" title="0">ai.deps.SetLoading(true, "Explaining code...")
        ai.deps.RefreshUI()
        return ai.deps.ExplainFiles()</span>
}

// Improve handles the /improve command
func (ai *AICommands) Improve(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(ai.deps.FileContext.Files) == 0 </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "No files loaded. Use /load to load files first.")
                return nil
        }</span>

        <span class="cov0" title="0">if ai.deps.APIClient == nil </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "Please set DEEPSEEK_API_KEY environment variable")
                return nil
        }</span>

        <span class="cov0" title="0">ai.deps.SetLoading(true, "Generating improvement suggestions...")
        ai.deps.RefreshUI()
        return ai.deps.ImproveFiles()</span>
}

// getFileFromRecentContext analyzes recent user messages to find the most recently mentioned loaded file
func (ai *AICommands) getFileFromRecentContext() string <span class="cov8" title="1">{
        if len(ai.deps.Messages) == 0 || len(ai.deps.FileContext.Files) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Look at the last 5 user messages for file mentions
        <span class="cov8" title="1">messageCount := 0
        for i := len(ai.deps.Messages) - 1; i &gt;= 0 &amp;&amp; messageCount &lt; 5; i-- </span><span class="cov8" title="1">{
                message := ai.deps.Messages[i]

                // Skip AI responses (they typically start with system indicators or have certain patterns)
                if strings.HasPrefix(message, "DeeCLI:") || strings.HasPrefix(message, "ü§ñ") ||
                   strings.Contains(message, "üìù") || strings.Contains(message, "system:") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">messageCount++

                // Look for file mentions in user messages
                if filePath := ai.extractFileFromMessage(message); filePath != "" </span><span class="cov8" title="1">{
                        return filePath
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// extractFileFromMessage extracts a loaded file path mentioned in a message
func (ai *AICommands) extractFileFromMessage(message string) string <span class="cov8" title="1">{
        // Pattern to match file paths with extensions
        filePattern := regexp.MustCompile(`\b([a-zA-Z0-9_\-./]+\.[a-zA-Z0-9]+)\b`)
        matches := filePattern.FindAllString(message, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                // Clean the match
                cleanMatch := strings.TrimSpace(match)

                // Check if this file is currently loaded
                for _, loadedFile := range ai.deps.FileContext.Files </span><span class="cov8" title="1">{
                        // Direct match
                        if loadedFile.RelPath == cleanMatch || loadedFile.Path == cleanMatch </span><span class="cov8" title="1">{
                                return loadedFile.RelPath
                        }</span>

                        // Basename match
                        <span class="cov8" title="1">if filepath.Base(loadedFile.RelPath) == filepath.Base(cleanMatch) </span><span class="cov8" title="1">{
                                return loadedFile.RelPath
                        }</span>

                        // Contains match (for partial paths)
                        <span class="cov8" title="1">if strings.Contains(loadedFile.RelPath, cleanMatch) </span><span class="cov0" title="0">{
                                return loadedFile.RelPath
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// showInteractiveFileSelection displays a numbered list of loaded files for user selection
func (ai *AICommands) showInteractiveFileSelection() tea.Cmd <span class="cov0" title="0">{
        if len(ai.deps.FileContext.Files) == 0 </span><span class="cov0" title="0">{
                ai.deps.MessageLogger("system", "No files loaded. Use /load &lt;file&gt; to load files first, or specify a file with /edit &lt;filepath&gt;")
                return nil
        }</span>

        <span class="cov0" title="0">if len(ai.deps.FileContext.Files) == 1 </span><span class="cov0" title="0">{
                // Only one file loaded, use it directly
                file := ai.deps.FileContext.Files[0]
                config := editor.Config{
                        MessageProvider: func() []string </span><span class="cov0" title="0">{ return ai.deps.Messages }</span>,
                        MessageLogger:   ai.deps.MessageLogger,
                }
                <span class="cov0" title="0">ai.deps.MessageLogger("system", fmt.Sprintf("üìù Opening only loaded file: %s", file.RelPath))
                return editor.OpenFileWithInstructions(file.RelPath, config)</span>
        }

        // Multiple files - show selection menu
        <span class="cov0" title="0">var fileList strings.Builder
        fileList.WriteString("üìù Edit which file?\n")

        for i, file := range ai.deps.FileContext.Files </span><span class="cov0" title="0">{
                fileList.WriteString(fmt.Sprintf("[%d] %s\n", i+1, file.RelPath))
        }</span>

        <span class="cov0" title="0">fileList.WriteString("Enter number (1-")
        fileList.WriteString(fmt.Sprintf("%d", len(ai.deps.FileContext.Files)))
        fileList.WriteString(") or filename:")

        ai.deps.MessageLogger("system", fileList.String())
        return nil</span>
}

// Edit handles the /edit command (both with and without arguments)
func (ai *AICommands) Edit(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                // First, try to find a file from recent conversation context
                if contextFile := ai.getFileFromRecentContext(); contextFile != "" </span><span class="cov0" title="0">{
                        config := editor.Config{
                                MessageProvider: func() []string </span><span class="cov0" title="0">{ return ai.deps.Messages }</span>,
                                MessageLogger:   ai.deps.MessageLogger,
                        }
                        <span class="cov0" title="0">ai.deps.MessageLogger("system", fmt.Sprintf("üìù Opening file from context: %s", contextFile))
                        return editor.OpenFileWithInstructions(contextFile, config)</span>
                }

                // If no context, show interactive file selection
                <span class="cov0" title="0">return ai.showInteractiveFileSelection()</span>
        }

        // Check if the argument is a number (for file selection)
        <span class="cov0" title="0">if fileIndex, err := strconv.Atoi(args[0]); err == nil </span><span class="cov0" title="0">{
                if fileIndex &gt;= 1 &amp;&amp; fileIndex &lt;= len(ai.deps.FileContext.Files) </span><span class="cov0" title="0">{
                        selectedFile := ai.deps.FileContext.Files[fileIndex-1]
                        config := editor.Config{
                                MessageProvider: func() []string </span><span class="cov0" title="0">{ return ai.deps.Messages }</span>,
                                MessageLogger:   ai.deps.MessageLogger,
                        }
                        <span class="cov0" title="0">ai.deps.MessageLogger("system", fmt.Sprintf("üìù Opening selected file [%d]: %s", fileIndex, selectedFile.RelPath))
                        return editor.OpenFileWithInstructions(selectedFile.RelPath, config)</span>
                } else<span class="cov0" title="0"> {
                        ai.deps.MessageLogger("system", fmt.Sprintf("Invalid file number. Please use 1-%d", len(ai.deps.FileContext.Files)))
                        return nil
                }</span>
        }

        // Open specific file in editor
        <span class="cov0" title="0">config := editor.Config{
                MessageProvider: func() []string </span><span class="cov0" title="0">{ return ai.deps.Messages }</span>,
                MessageLogger:   ai.deps.MessageLogger,
        }
        <span class="cov0" title="0">return editor.OpenFileWithInstructions(args[0], config)</span>
}

</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// ConfigCommands handles configuration-related chat commands
type ConfigCommands struct {
        deps Dependencies
}

// NewConfigCommands creates a new config commands handler
func NewConfigCommands(deps Dependencies) *ConfigCommands <span class="cov8" title="1">{
        return &amp;ConfigCommands{deps: deps}
}</span>

// Config handles the /config command
func (cc *ConfigCommands) Config(args []string) tea.Cmd <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                // No arguments - show current configuration
                cc.showConfig()
                return nil
        }</span>

        <span class="cov0" title="0">cc.handleConfigCommand(args)
        return nil</span>
}

// KeySetup handles the /keysetup command
func (cc *ConfigCommands) KeySetup(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                keyType := args[0]
                switch keyType </span>{
                case "newline", "break":<span class="cov0" title="0">
                        cc.deps.SetKeyDetection(true, "newline")</span>
                case "history-back", "back", "previous":<span class="cov0" title="0">
                        cc.deps.SetKeyDetection(true, "history-back")</span>
                case "history-forward", "forward", "next":<span class="cov0" title="0">
                        cc.deps.SetKeyDetection(true, "history-forward")</span>
                default:<span class="cov0" title="0">
                        cc.deps.MessageLogger("system", "Unknown key type: "+keyType)
                        cc.deps.MessageLogger("system", "Usage: /keysetup [newline|history-back|history-forward]")</span>
                }
        } else<span class="cov0" title="0"> {
                // No argument - show current key bindings
                cc.showKeyBindings()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// History handles the /history command
func (cc *ConfigCommands) History(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                subCmd := args[0]
                switch subCmd </span>{
                case "clear":<span class="cov0" title="0">
                        cc.deps.InputHistory = cc.deps.InputHistory[:0] // Clear slice
                        if cc.deps.HistoryManager != nil </span><span class="cov0" title="0">{
                                if err := cc.deps.HistoryManager.Clear(); err != nil </span><span class="cov0" title="0">{
                                        cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Failed to clear persistent history: %v", err))
                                }</span> else<span class="cov0" title="0"> {
                                        cc.deps.MessageLogger("system", "‚úÖ History cleared (both in-memory and persistent)")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cc.deps.MessageLogger("system", "‚úÖ In-memory history cleared")
                        }</span>
                case "show", "list":<span class="cov0" title="0">
                        cc.deps.ShowHistory()</span>
                default:<span class="cov0" title="0">
                        cc.deps.MessageLogger("system", "Unknown history command: "+subCmd)
                        cc.deps.MessageLogger("system", "Usage: /history [show|clear]")</span>
                }
        } else<span class="cov0" title="0"> {
                // No argument - show history
                cc.deps.ShowHistory()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// handleConfigCommand processes specific config subcommands
func (cc *ConfigCommands) handleConfigCommand(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch args[0] </span>{
        case "show":<span class="cov0" title="0">
                cc.showConfig()</span>
        case "init":<span class="cov0" title="0">
                cc.handleConfigInit()</span>
        case "set":<span class="cov0" title="0">
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "Usage: /config set &lt;key&gt; &lt;value&gt; [--global|--project]")
                        cc.deps.MessageLogger("system", "Keys: api-key, model, temperature, max-tokens")
                        return
                }</span>
                <span class="cov0" title="0">cc.handleConfigSet(args[1], args[2], args[3:])</span>
        case "get":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "Usage: /config get &lt;key&gt;")
                        cc.deps.MessageLogger("system", "Keys: api-key, model, temperature, max-tokens")
                        return
                }</span>
                <span class="cov0" title="0">cc.handleConfigGet(args[1])</span>
        case "editor":<span class="cov0" title="0">
                cc.handleEditorConfig(args[1:])</span>
        case "model":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "Usage: /config model &lt;model_name&gt; [--global|--project]")
                        cc.deps.MessageLogger("system", "Common models: deepseek-chat, deepseek-reasoner")
                }</span> else<span class="cov0" title="0"> {
                        cc.handleConfigSet("model", args[1], args[2:])
                }</span>
        case "temperature":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "Usage: /config temperature &lt;0.0-2.0&gt; [--global|--project]")
                        cc.deps.MessageLogger("system", "Examples: 0.1 (focused), 0.7 (balanced), 1.5 (creative)")
                }</span> else<span class="cov0" title="0"> {
                        cc.handleConfigSet("temperature", args[1], args[2:])
                }</span>
        case "max-tokens":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "Usage: /config max-tokens &lt;number&gt; [--global|--project]")
                        cc.deps.MessageLogger("system", "Examples: 1024 (short), 2048 (default), 4096 (long)")
                }</span> else<span class="cov0" title="0"> {
                        cc.handleConfigSet("max-tokens", args[1], args[2:])
                }</span>
        case "help":<span class="cov0" title="0">
                cc.showConfigHelp()</span>
        default:<span class="cov0" title="0">
                cc.deps.MessageLogger("system", fmt.Sprintf("Unknown config command: %s", args[0]))
                cc.showConfigHelp()</span>
        }
}

// showConfig displays current configuration
func (cc *ConfigCommands) showConfig() <span class="cov8" title="1">{
        cc.deps.MessageLogger("system", "üìã Current Configuration:")

        if cc.deps.ConfigManager != nil </span><span class="cov8" title="1">{
                // Reload config to get latest
                if err := cc.deps.ConfigManager.Load(); err != nil </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Warning: Failed to load config: %v", err))
                }</span>

                <span class="cov8" title="1">cfg := cc.deps.ConfigManager.Get()

                // Show config sources
                if cc.deps.ConfigManager.GlobalConfigExists() </span><span class="cov8" title="1">{
                        cc.deps.MessageLogger("system", "  ‚úì Global config: ~/.deecli/config.yaml")
                }</span>
                <span class="cov8" title="1">if cc.deps.ConfigManager.ProjectConfigExists() </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "  ‚úì Project config: ./.deecli/config.yaml")
                }</span>
                <span class="cov8" title="1">if os.Getenv("DEEPSEEK_API_KEY") != "" </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "  ‚úì Environment: DEEPSEEK_API_KEY")
                }</span>

                <span class="cov8" title="1">cc.deps.MessageLogger("system", "")

                // Show merged configuration with proper masking
                apiKeyDisplay := cfg.APIKey
                if len(apiKeyDisplay) &gt; 8 </span><span class="cov8" title="1">{
                        apiKeyDisplay = apiKeyDisplay[:4] + "..." + apiKeyDisplay[len(apiKeyDisplay)-4:]
                }</span> else<span class="cov0" title="0"> if apiKeyDisplay != "" </span><span class="cov0" title="0">{
                        apiKeyDisplay = "****"
                }</span> else<span class="cov0" title="0"> {
                        apiKeyDisplay = "Not set"
                }</span>

                <span class="cov8" title="1">cc.deps.MessageLogger("system", fmt.Sprintf("  API Key: %s", apiKeyDisplay))
                cc.deps.MessageLogger("system", fmt.Sprintf("  Model: %s", cfg.Model))
                cc.deps.MessageLogger("system", fmt.Sprintf("  Temperature: %.2f", cfg.Temperature))
                cc.deps.MessageLogger("system", fmt.Sprintf("  Max Tokens: %d", cfg.MaxTokens))</span>
        } else<span class="cov0" title="0"> {
                cc.deps.MessageLogger("system", "‚ö†Ô∏è Config manager not available")
        }</span>

        // Show editor configuration
        <span class="cov8" title="1">editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = os.Getenv("VISUAL")
        }</span>
        <span class="cov8" title="1">if editor == "" </span><span class="cov0" title="0">{
                editor = "auto-detect"
        }</span>
        <span class="cov8" title="1">cc.deps.MessageLogger("system", fmt.Sprintf("  Editor: %s", editor))</span>
}

// handleEditorConfig processes editor configuration
func (cc *ConfigCommands) handleEditorConfig(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", "Usage: /config editor &lt;editor_name&gt; [--save|--global]")
                cc.deps.MessageLogger("system", "Options:")
                cc.deps.MessageLogger("system", "  (no flag)  - Set for current session only")
                cc.deps.MessageLogger("system", "  --save     - Save to project config (./.deecli/config.yaml)")
                cc.deps.MessageLogger("system", "  --global   - Save to global config (~/.deecli/config.yaml)")
                return
        }</span>

        // Parse flags
        <span class="cov0" title="0">editorParts := []string{}
        saveFlag := ""

        for _, arg := range args </span><span class="cov0" title="0">{
                if arg == "--save" </span><span class="cov0" title="0">{
                        saveFlag = "project"
                }</span> else<span class="cov0" title="0"> if arg == "--global" </span><span class="cov0" title="0">{
                        saveFlag = "global"
                }</span> else<span class="cov0" title="0"> {
                        editorParts = append(editorParts, arg)
                }</span>
        }

        <span class="cov0" title="0">if len(editorParts) == 0 </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", "‚ùå Editor name required")
                return
        }</span>

        <span class="cov0" title="0">newEditor := strings.Join(editorParts, " ")

        // Verify editor exists
        if _, err := exec.LookPath(strings.Fields(newEditor)[0]); err != nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Warning: Editor '%s' not found in PATH", newEditor))
        }</span>

        // Set for current session
        <span class="cov0" title="0">os.Setenv("EDITOR", newEditor)

        // Handle persistence if requested
        if saveFlag != "" &amp;&amp; cc.deps.ConfigManager != nil </span><span class="cov0" title="0">{
                if saveFlag == "global" </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Editor set to: %s", newEditor))
                        cc.deps.MessageLogger("system", "üí° Note: Editor setting is environment-based. To persist globally, add to ~/.bashrc:")
                        cc.deps.MessageLogger("system", fmt.Sprintf("     export EDITOR=\"%s\"", newEditor))
                }</span> else<span class="cov0" title="0"> {
                        cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Editor set to: %s", newEditor))
                        cc.deps.MessageLogger("system", "üí° Note: Editor setting is environment-based. To persist in project, add to shell config or .env")
                }</span>
        } else<span class="cov0" title="0"> {
                cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Editor set to: %s (current session only)", newEditor))
        }</span>
}

// showKeyBindings displays current key bindings
func (cc *ConfigCommands) showKeyBindings() <span class="cov0" title="0">{
        cc.deps.MessageLogger("system", "üéπ Current Key Bindings:")

        if cc.deps.ConfigManager != nil </span><span class="cov0" title="0">{
                newlineKey := cc.formatKeyForDisplay(cc.deps.ConfigManager.GetNewlineKey())
                historyBackKey := cc.formatKeyForDisplay(cc.deps.ConfigManager.GetHistoryBackKey())
                historyForwardKey := cc.formatKeyForDisplay(cc.deps.ConfigManager.GetHistoryForwardKey())

                cc.deps.MessageLogger("system", fmt.Sprintf("  ‚Ä¢ Newline:         %s", newlineKey))
                cc.deps.MessageLogger("system", fmt.Sprintf("  ‚Ä¢ History Back:    %s", historyBackKey))
                cc.deps.MessageLogger("system", fmt.Sprintf("  ‚Ä¢ History Forward: %s", historyForwardKey))
        }</span> else<span class="cov0" title="0"> {
                cc.deps.MessageLogger("system", "  ‚Ä¢ Newline:         Ctrl+J (default)")
                cc.deps.MessageLogger("system", "  ‚Ä¢ History Back:    Ctrl+P (default)")
                cc.deps.MessageLogger("system", "  ‚Ä¢ History Forward: Ctrl+N (default)")
        }</span>

        <span class="cov0" title="0">cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "To change a key binding:")
        cc.deps.MessageLogger("system", "  /keysetup newline        - Configure newline key")
        cc.deps.MessageLogger("system", "  /keysetup history-back   - Configure history back key")
        cc.deps.MessageLogger("system", "  /keysetup history-forward - Configure history forward key")</span>
}

// formatKeyForDisplay formats a key string for user-friendly display
func (cc *ConfigCommands) formatKeyForDisplay(key string) string <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return "Ctrl+J" // Default
        }</span>

        // Split by + and capitalize each part
        <span class="cov0" title="0">parts := strings.Split(key, "+")
        for i, part := range parts </span><span class="cov0" title="0">{
                switch strings.ToLower(part) </span>{
                case "ctrl":<span class="cov0" title="0">
                        parts[i] = "Ctrl"</span>
                case "alt":<span class="cov0" title="0">
                        parts[i] = "Alt"</span>
                case "shift":<span class="cov0" title="0">
                        parts[i] = "Shift"</span>
                case "enter":<span class="cov0" title="0">
                        parts[i] = "Enter"</span>
                default:<span class="cov0" title="0">
                        // Uppercase single letters (j -&gt; J, m -&gt; M)
                        if len(part) == 1 </span><span class="cov0" title="0">{
                                parts[i] = strings.ToUpper(part)
                        }</span> else<span class="cov0" title="0"> {
                                // Capitalize first letter of words
                                parts[i] = strings.Title(part)
                        }</span>
                }
        }
        <span class="cov0" title="0">return strings.Join(parts, "+")</span>
}

// handleConfigInit handles interactive configuration initialization
func (cc *ConfigCommands) handleConfigInit() <span class="cov0" title="0">{
        cc.deps.MessageLogger("system", "üîß Configuration Initialization")
        cc.deps.MessageLogger("system", "================================")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "This will set up your DeeCLI configuration.")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "For interactive setup, use the CLI command:")
        cc.deps.MessageLogger("system", "  deecli config init")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "Or use /config set commands to configure individual settings:")
        cc.deps.MessageLogger("system", "  /config set api-key &lt;your-key&gt;")
        cc.deps.MessageLogger("system", "  /config set model deepseek-chat")
        cc.deps.MessageLogger("system", "  /config set temperature 0.7")
        cc.deps.MessageLogger("system", "  /config set max-tokens 2048")
}</span>

// handleConfigSet sets a configuration value
func (cc *ConfigCommands) handleConfigSet(key, value string, flags []string) <span class="cov8" title="1">{
        if cc.deps.ConfigManager == nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", "‚ùå Configuration manager not available")
                return
        }</span>

        // Parse flags
        <span class="cov8" title="1">scope := ""
        for _, flag := range flags </span><span class="cov0" title="0">{
                if flag == "--global" </span><span class="cov0" title="0">{
                        scope = "global"
                }</span> else<span class="cov0" title="0"> if flag == "--project" </span><span class="cov0" title="0">{
                        scope = "project"
                }</span>
        }

        // Load current config
        <span class="cov8" title="1">if err := cc.deps.ConfigManager.Load(); err != nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Failed to load configuration: %v", err))
                return
        }</span>

        <span class="cov8" title="1">cfg := cc.deps.ConfigManager.Get()
        newCfg := *cfg

        // Update the specific field
        var displayValue string
        switch key </span>{
        case "api-key":<span class="cov0" title="0">
                newCfg.APIKey = value
                if len(value) &gt; 8 </span><span class="cov0" title="0">{
                        displayValue = value[:4] + "..." + value[len(value)-4:]
                }</span> else<span class="cov0" title="0"> {
                        displayValue = "****"
                }</span>
                <span class="cov0" title="0">cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ API key updated: %s", displayValue))</span>

        case "model":<span class="cov8" title="1">
                newCfg.Model = value
                cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Model set to: %s", value))</span>

        case "temperature":<span class="cov8" title="1">
                var temp float64
                if _, err := fmt.Sscanf(value, "%f", &amp;temp); err != nil </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Invalid temperature value: %s", value))
                        return
                }</span>
                <span class="cov8" title="1">if temp &lt; 0.0 || temp &gt; 2.0 </span><span class="cov8" title="1">{
                        cc.deps.MessageLogger("system", "‚ùå Temperature must be between 0.0 and 2.0")
                        return
                }</span>
                <span class="cov8" title="1">newCfg.Temperature = temp
                cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Temperature set to: %.2f", temp))</span>

        case "max-tokens":<span class="cov8" title="1">
                var tokens int
                if _, err := fmt.Sscanf(value, "%d", &amp;tokens); err != nil </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Invalid max-tokens value: %s", value))
                        return
                }</span>
                <span class="cov8" title="1">if tokens &lt;= 0 </span><span class="cov8" title="1">{
                        cc.deps.MessageLogger("system", "‚ùå Max tokens must be positive")
                        return
                }</span>
                <span class="cov8" title="1">newCfg.MaxTokens = tokens
                cc.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Max tokens set to: %d", tokens))</span>

        default:<span class="cov8" title="1">
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Unknown config key: %s", key))
                cc.deps.MessageLogger("system", "Valid keys: api-key, model, temperature, max-tokens")
                return</span>
        }

        // Determine where to save
        <span class="cov8" title="1">var err error
        if scope == "global" || (!cc.deps.ConfigManager.ProjectConfigExists() &amp;&amp; scope != "project") </span><span class="cov8" title="1">{
                err = cc.deps.ConfigManager.SaveGlobal(&amp;newCfg)
                if err == nil </span><span class="cov8" title="1">{
                        cc.deps.MessageLogger("system", "   Saved to global config: ~/.deecli/config.yaml")
                }</span>
        } else<span class="cov0" title="0"> {
                err = cc.deps.ConfigManager.SaveProject(&amp;newCfg)
                if err == nil </span><span class="cov0" title="0">{
                        cc.deps.MessageLogger("system", "   Saved to project config: ./.deecli/config.yaml")
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Failed to save configuration: %v", err))
                return
        }</span>

        // Reload to apply changes
        <span class="cov8" title="1">if err := cc.deps.ConfigManager.Load(); err != nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Configuration saved but reload failed: %v", err))
        }</span> else<span class="cov8" title="1"> {
                cc.deps.MessageLogger("system", "   Configuration reloaded and applied")
        }</span>
}

// handleConfigGet retrieves a configuration value
func (cc *ConfigCommands) handleConfigGet(key string) <span class="cov0" title="0">{
        if cc.deps.ConfigManager == nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", "‚ùå Configuration manager not available")
                return
        }</span>

        // Reload config to get latest
        <span class="cov0" title="0">if err := cc.deps.ConfigManager.Load(); err != nil </span><span class="cov0" title="0">{
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Warning: Failed to load config: %v", err))
        }</span>

        <span class="cov0" title="0">cfg := cc.deps.ConfigManager.Get()

        switch key </span>{
        case "api-key":<span class="cov0" title="0">
                apiKeyDisplay := cfg.APIKey
                if len(apiKeyDisplay) &gt; 8 </span><span class="cov0" title="0">{
                        apiKeyDisplay = apiKeyDisplay[:4] + "..." + apiKeyDisplay[len(apiKeyDisplay)-4:]
                }</span> else<span class="cov0" title="0"> if apiKeyDisplay != "" </span><span class="cov0" title="0">{
                        apiKeyDisplay = "****"
                }</span> else<span class="cov0" title="0"> {
                        apiKeyDisplay = "Not set"
                }</span>
                <span class="cov0" title="0">cc.deps.MessageLogger("system", fmt.Sprintf("API Key: %s", apiKeyDisplay))</span>

        case "model":<span class="cov0" title="0">
                cc.deps.MessageLogger("system", fmt.Sprintf("Model: %s", cfg.Model))</span>

        case "temperature":<span class="cov0" title="0">
                cc.deps.MessageLogger("system", fmt.Sprintf("Temperature: %.2f", cfg.Temperature))</span>

        case "max-tokens":<span class="cov0" title="0">
                cc.deps.MessageLogger("system", fmt.Sprintf("Max Tokens: %d", cfg.MaxTokens))</span>

        default:<span class="cov0" title="0">
                cc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Unknown config key: %s", key))
                cc.deps.MessageLogger("system", "Valid keys: api-key, model, temperature, max-tokens")</span>
        }
}

// showConfigHelp displays help for config command
func (cc *ConfigCommands) showConfigHelp() <span class="cov8" title="1">{
        cc.deps.MessageLogger("system", "üìã Config Command Help")
        cc.deps.MessageLogger("system", "======================")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "Usage: /config [command] [args]")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "Commands:")
        cc.deps.MessageLogger("system", "  /config                  - Show current configuration")
        cc.deps.MessageLogger("system", "  /config show             - Show detailed configuration")
        cc.deps.MessageLogger("system", "  /config init             - Initialize configuration")
        cc.deps.MessageLogger("system", "  /config get &lt;key&gt;        - Get a specific config value")
        cc.deps.MessageLogger("system", "  /config set &lt;key&gt; &lt;val&gt;  - Set a config value")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "Shortcuts:")
        cc.deps.MessageLogger("system", "  /config model &lt;name&gt;     - Set model quickly")
        cc.deps.MessageLogger("system", "  /config temperature &lt;val&gt; - Set temperature (0.0-2.0)")
        cc.deps.MessageLogger("system", "  /config max-tokens &lt;num&gt;  - Set max tokens")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "Flags:")
        cc.deps.MessageLogger("system", "  --global                 - Save to global config")
        cc.deps.MessageLogger("system", "  --project                - Save to project config")
        cc.deps.MessageLogger("system", "")
        cc.deps.MessageLogger("system", "Examples:")
        cc.deps.MessageLogger("system", "  /config model deepseek-reasoner --global")
        cc.deps.MessageLogger("system", "  /config set temperature 0.7")
        cc.deps.MessageLogger("system", "  /config get model")
}</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// FileCommands handles file-related chat commands
type FileCommands struct {
        deps Dependencies
}

// NewFileCommands creates a new file commands handler
func NewFileCommands(deps Dependencies) *FileCommands <span class="cov0" title="0">{
        return &amp;FileCommands{deps: deps}
}</span>

// Load handles the /load command
func (fc *FileCommands) Load(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fc.deps.MessageLogger("system", "Usage: /load &lt;filepath&gt;")
                return nil
        }</span>

        <span class="cov0" title="0">patterns := args
        err := fc.deps.FileContext.LoadFiles(patterns)
        if err != nil </span><span class="cov0" title="0">{
                fc.deps.MessageLogger("system", fmt.Sprintf("Error loading files: %v", err))
        }</span> else<span class="cov0" title="0"> {
                fc.deps.MessageLogger("system", fc.deps.FileContext.GetInfo())
                fc.deps.RefreshUI()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Add handles the /add command
func (fc *FileCommands) Add(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                fc.deps.MessageLogger("system", "Usage: /add &lt;filepath&gt;")
                return nil
        }</span>

        <span class="cov0" title="0">patterns := args
        err := fc.deps.FileContext.LoadFiles(patterns)
        if err != nil </span><span class="cov0" title="0">{
                fc.deps.MessageLogger("system", fmt.Sprintf("Error adding files: %v", err))
        }</span> else<span class="cov0" title="0"> {
                fc.deps.MessageLogger("system", fc.deps.FileContext.GetInfo())
                fc.deps.RefreshUI()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// List handles the /list command
func (fc *FileCommands) List(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(fc.deps.FileContext.Files) == 0 </span><span class="cov0" title="0">{
                fc.deps.MessageLogger("system", "No files loaded")
        }</span> else<span class="cov0" title="0"> {
                fc.deps.MessageLogger("system", fc.deps.FileContext.GetInfo())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Clear handles the /clear command
func (fc *FileCommands) Clear(args []string) tea.Cmd <span class="cov0" title="0">{
        fc.deps.FileContext.Clear()
        fc.deps.MessageLogger("system", "All files cleared")
        fc.deps.RefreshUI()
        return nil
}</span>

// Reload handles the /reload command
func (fc *FileCommands) Reload(args []string) tea.Cmd <span class="cov0" title="0">{
        var patterns []string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                patterns = args
        }</span>

        <span class="cov0" title="0">results, err := fc.deps.FileContext.ReloadFiles(patterns)
        if err != nil </span><span class="cov0" title="0">{
                fc.deps.MessageLogger("system", fmt.Sprintf("‚ùå Error reloading files: %v", err))
                return nil
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                if len(patterns) == 0 </span><span class="cov0" title="0">{
                        fc.deps.MessageLogger("system", "No files loaded to reload")
                }</span> else<span class="cov0" title="0"> {
                        fc.deps.MessageLogger("system", "No matching loaded files found")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Show results with changes
        <span class="cov0" title="0">var msg strings.Builder
        changedCount := 0
        unchangedCount := 0
        errorCount := 0

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Status == "error" </span><span class="cov0" title="0">{
                        errorCount++
                }</span> else<span class="cov0" title="0"> if result.Status == "changed" </span><span class="cov0" title="0">{
                        changedCount++
                }</span> else<span class="cov0" title="0"> {
                        unchangedCount++
                }</span>
        }

        <span class="cov0" title="0">if changedCount &gt; 0 &amp;&amp; unchangedCount &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("‚úÖ Reloaded %d files (%d changed, %d unchanged):\n", len(results), changedCount, unchangedCount))
        }</span> else<span class="cov0" title="0"> if changedCount &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("‚úÖ Reloaded %d files (all changed):\n", len(results)))
        }</span> else<span class="cov0" title="0"> if unchangedCount &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("‚úÖ Reloaded %d files (no changes detected):\n", len(results)))
        }</span>

        <span class="cov0" title="0">for _, result := range results </span><span class="cov0" title="0">{
                icon := fc.getFileTypeIcon(result.Language)
                if result.Status == "error" </span><span class="cov0" title="0">{
                        msg.WriteString(fmt.Sprintf("  ‚ùå %s %s - Error: %s\n", icon, result.Path, result.Error))
                }</span> else<span class="cov0" title="0"> if result.Status == "changed" </span><span class="cov0" title="0">{
                        oldSizeStr := fc.formatFileSize(result.OldSize)
                        newSizeStr := fc.formatFileSize(result.NewSize)
                        msg.WriteString(fmt.Sprintf("  %s %s (%s ‚Üí %s)\n", icon, result.Path, oldSizeStr, newSizeStr))
                }</span> else<span class="cov0" title="0"> {
                        sizeStr := fc.formatFileSize(result.NewSize)
                        msg.WriteString(fmt.Sprintf("  %s %s (%s)\n", icon, result.Path, sizeStr))
                }</span>
        }

        <span class="cov0" title="0">fc.deps.MessageLogger("system", strings.TrimSuffix(msg.String(), "\n"))
        fc.deps.RefreshUI()
        return nil</span>
}

// Helper functions for file operations
func (fc *FileCommands) getFileTypeIcon(language string) string <span class="cov0" title="0">{
        iconMap := map[string]string{
                "go":         "üêπ",
                "javascript": "üü®",
                "typescript": "üî∑",
                "python":     "üêç",
                "rust":       "ü¶Ä",
                "java":       "‚òï",
                "c":          "‚ö°",
                "cpp":        "‚ö°",
                "html":       "üåê",
                "css":        "üé®",
                "json":       "üìã",
                "yaml":       "üìù",
                "markdown":   "üìñ",
                "sql":        "üóÉÔ∏è",
                "dockerfile": "üê≥",
                "makefile":   "üî®",
                "bash":       "üñ•Ô∏è",
                "text":       "üìÑ",
        }

        if icon, ok := iconMap[language]; ok </span><span class="cov0" title="0">{
                return icon
        }</span>
        <span class="cov0" title="0">return "üìÑ"</span>
}

func (fc *FileCommands) formatFileSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%db", bytes)
        }</span>

        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>

        <span class="cov0" title="0">units := []string{"KB", "MB", "GB", "TB"}
        return fmt.Sprintf("%.1f%s", float64(bytes)/float64(div), units[exp])</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// Handler manages chat command parsing and routing
type Handler struct {
        fileCommands   *FileCommands
        aiCommands     *AICommands
        configCommands *ConfigCommands
        systemCommands *SystemCommands
}

// NewHandler creates a new command handler
func NewHandler(deps Dependencies) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                fileCommands:   NewFileCommands(deps),
                aiCommands:     NewAICommands(deps),
                configCommands: NewConfigCommands(deps),
                systemCommands: NewSystemCommands(deps),
        }
}</span>

// Handle processes a chat command and returns appropriate tea.Cmd
func (h *Handler) Handle(input string) tea.Cmd <span class="cov0" title="0">{
        parts := strings.Fields(input)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">command := parts[0]
        args := parts[1:]

        switch command </span>{
        // File commands
        case "/load":<span class="cov0" title="0">
                return h.fileCommands.Load(args)</span>
        case "/add":<span class="cov0" title="0">
                return h.fileCommands.Add(args)</span>
        case "/list":<span class="cov0" title="0">
                return h.fileCommands.List(args)</span>
        case "/clear":<span class="cov0" title="0">
                return h.fileCommands.Clear(args)</span>
        case "/reload":<span class="cov0" title="0">
                return h.fileCommands.Reload(args)</span>

        // AI commands
        case "/analyze":<span class="cov0" title="0">
                return h.aiCommands.Analyze(args)</span>
        case "/explain":<span class="cov0" title="0">
                return h.aiCommands.Explain(args)</span>
        case "/improve":<span class="cov0" title="0">
                return h.aiCommands.Improve(args)</span>
        case "/edit":<span class="cov0" title="0">
                return h.aiCommands.Edit(args)</span>

        // Config commands
        case "/config":<span class="cov0" title="0">
                return h.configCommands.Config(args)</span>
        case "/keysetup":<span class="cov0" title="0">
                return h.configCommands.KeySetup(args)</span>
        case "/history":<span class="cov0" title="0">
                return h.configCommands.History(args)</span>

        // System commands
        case "/help":<span class="cov0" title="0">
                return h.systemCommands.Help(args)</span>
        case "/quit", "/exit":<span class="cov0" title="0">
                return h.systemCommands.Quit(args)</span>
        case "/create":<span class="cov0" title="0">
                return h.systemCommands.Create(args)</span>

        default:<span class="cov0" title="0">
                h.systemCommands.ShowUnknownCommand(command)
                return nil</span>
        }
}</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"

        "github.com/antenore/deecli/internal/editor"
        tea "github.com/charmbracelet/bubbletea"
)

// SystemCommands handles system-related chat commands
type SystemCommands struct {
        deps Dependencies
}

// NewSystemCommands creates a new system commands handler
func NewSystemCommands(deps Dependencies) *SystemCommands <span class="cov0" title="0">{
        return &amp;SystemCommands{deps: deps}
}</span>

// Help handles the /help command
func (sc *SystemCommands) Help(args []string) tea.Cmd <span class="cov0" title="0">{
        // Toggle help visibility
        sc.deps.SetHelpVisible(!sc.deps.HelpVisible)
        return nil
}</span>

// Quit handles the /quit and /exit commands
func (sc *SystemCommands) Quit(args []string) tea.Cmd <span class="cov0" title="0">{
        return tea.Quit
}</span>

// Create handles the /create command
func (sc *SystemCommands) Create(args []string) tea.Cmd <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                sc.deps.MessageLogger("system", "Usage: /create &lt;filepath&gt; - Creates a new file with AI suggestions")
                return nil
        }</span>

        // Use the editor module for new file creation
        <span class="cov0" title="0">config := editor.Config{
                MessageProvider: func() []string </span><span class="cov0" title="0">{ return sc.deps.Messages }</span>,
                MessageLogger:   sc.deps.MessageLogger,
        }
        <span class="cov0" title="0">return editor.CreateAndEditNewFile(args[0], config)</span>
}

// ShowUnknownCommand handles unknown commands
func (sc *SystemCommands) ShowUnknownCommand(command string) <span class="cov0" title="0">{
        sc.deps.MessageLogger("system", fmt.Sprintf("Unknown command: %s. Type /help for available commands.", command))
}</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package chat

import (
        "os"
        "path/filepath"
        "strings"
)

type CompletionEngine struct {
        commands []string
}

func NewCompletionEngine() *CompletionEngine <span class="cov8" title="1">{
        return &amp;CompletionEngine{
                commands: []string{
                        "/load",
                        "/add",
                        "/list",
                        "/clear",
                        "/reload",
                        "/analyze",
                        "/edit",
                        "/create",
                        "/improve",
                        "/explain",
                        "/history",
                        "/keysetup",
                        "/config",
                        "/help",
                        "/quit",
                        "/exit",
                        "/sessions",
                },
        }
}</span>

func (ce *CompletionEngine) Complete(input string, cursorPos int) ([]string, string) <span class="cov8" title="1">{
        if cursorPos &gt; len(input) </span><span class="cov0" title="0">{
                cursorPos = len(input)
        }</span>

        <span class="cov8" title="1">prefix := input[:cursorPos]

        if strings.HasPrefix(prefix, "/") </span><span class="cov8" title="1">{
                parts := strings.Fields(prefix)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        return ce.completeCommands("/"), "/"
                }</span>

                <span class="cov8" title="1">if len(parts) == 1 &amp;&amp; !strings.Contains(prefix, " ") </span><span class="cov0" title="0">{
                        return ce.completeCommands(parts[0]), parts[0]
                }</span>

                <span class="cov8" title="1">cmd := parts[0]

                // Handle /config subcommands
                if cmd == "/config" </span><span class="cov0" title="0">{
                        if len(parts) == 1 &amp;&amp; strings.HasSuffix(prefix, " ") </span><span class="cov0" title="0">{
                                // After "/config "
                                return ce.completeConfigSubcommands(""), ""
                        }</span> else<span class="cov0" title="0"> if len(parts) == 2 &amp;&amp; !strings.HasSuffix(prefix, " ") </span><span class="cov0" title="0">{
                                // Typing the subcommand
                                return ce.completeConfigSubcommands(parts[1]), parts[1]
                        }</span> else<span class="cov0" title="0"> if len(parts) == 2 &amp;&amp; strings.HasSuffix(prefix, " ") </span><span class="cov0" title="0">{
                                // After "/config &lt;subcommand&gt; "
                                subcmd := parts[1]
                                if subcmd == "get" || subcmd == "set" </span><span class="cov0" title="0">{
                                        return ce.completeConfigKeys(""), ""
                                }</span> else<span class="cov0" title="0"> if subcmd == "model" </span><span class="cov0" title="0">{
                                        return ce.completeModels(""), ""
                                }</span>
                        } else<span class="cov0" title="0"> if len(parts) == 3 &amp;&amp; !strings.HasSuffix(prefix, " ") </span><span class="cov0" title="0">{
                                // Typing the third argument
                                subcmd := parts[1]
                                if subcmd == "get" || subcmd == "set" </span><span class="cov0" title="0">{
                                        return ce.completeConfigKeys(parts[2]), parts[2]
                                }</span> else<span class="cov0" title="0"> if subcmd == "model" </span><span class="cov0" title="0">{
                                        return ce.completeModels(parts[2]), parts[2]
                                }</span>
                        } else<span class="cov0" title="0"> if len(parts) == 3 &amp;&amp; strings.HasSuffix(prefix, " ") &amp;&amp; parts[1] == "set" </span><span class="cov0" title="0">{
                                // After "/config set &lt;key&gt; " - suggest example values
                                key := parts[2]
                                return ce.completeConfigValues(key, ""), ""
                        }</span> else<span class="cov0" title="0"> if len(parts) == 4 &amp;&amp; !strings.HasSuffix(prefix, " ") &amp;&amp; parts[1] == "set" </span><span class="cov0" title="0">{
                                // Typing the value for set
                                key := parts[2]
                                return ce.completeConfigValues(key, parts[3]), parts[3]
                        }</span>
                }

                <span class="cov8" title="1">if cmd == "/load" || cmd == "/add" || cmd == "/reload" || cmd == "/edit" || cmd == "/create" </span><span class="cov8" title="1">{
                        // Find the current word being typed at cursor position
                        currentWord, wordStart := ce.getCurrentWord(input, cursorPos)
                        if wordStart &gt; 0 </span><span class="cov8" title="1">{ // We're after the command
                                return ce.completeFilePath(currentWord), currentWord
                        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(prefix, " ") </span><span class="cov0" title="0">{
                                return ce.completeFilePath(""), ""
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, ""</span>
}

func (ce *CompletionEngine) completeCommands(prefix string) []string <span class="cov0" title="0">{
        var matches []string
        for _, cmd := range ce.commands </span><span class="cov0" title="0">{
                if strings.HasPrefix(cmd, prefix) </span><span class="cov0" title="0">{
                        matches = append(matches, cmd)
                }</span>
        }
        <span class="cov0" title="0">return matches</span>
}

func (ce *CompletionEngine) completeFilePath(prefix string) []string <span class="cov8" title="1">{
        originalPrefix := prefix
        
        // Handle empty prefix specially - don't treat it as "."
        if prefix == "" </span><span class="cov8" title="1">{
                dir := "."
                showDotFiles := false
                
                entries, err := os.ReadDir(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">var matches []string
                for _, entry := range entries </span><span class="cov8" title="1">{
                        name := entry.Name()
                        
                        if strings.HasPrefix(name, ".") &amp;&amp; !showDotFiles </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">fullPath := name
                        if entry.IsDir() </span><span class="cov8" title="1">{
                                fullPath += "/"
                        }</span>
                        
                        <span class="cov8" title="1">matches = append(matches, fullPath)</span>
                }
                
                <span class="cov8" title="1">return matches</span>
        }

        // Handle non-empty prefix
        <span class="cov0" title="0">dir := filepath.Dir(prefix)
        base := filepath.Base(prefix)

        if strings.HasSuffix(prefix, "/") </span><span class="cov0" title="0">{
                dir = prefix
                base = ""
        }</span>

        <span class="cov0" title="0">if dir == "" </span><span class="cov0" title="0">{
                dir = "."
        }</span>
        
        // If user didn't type anything (empty original prefix), don't show dot files
        <span class="cov0" title="0">showDotFiles := originalPrefix != "" &amp;&amp; (strings.HasPrefix(base, ".") || strings.HasPrefix(originalPrefix, "."))

        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var matches []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                name := entry.Name()
                
                if strings.HasPrefix(name, ".") &amp;&amp; !showDotFiles </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if base == "" || strings.HasPrefix(name, base) </span><span class="cov0" title="0">{
                        fullPath := filepath.Join(dir, name)
                        if dir == "." </span><span class="cov0" title="0">{
                                fullPath = name
                        }</span>
                        
                        <span class="cov0" title="0">if entry.IsDir() </span><span class="cov0" title="0">{
                                fullPath += "/"
                        }</span>
                        
                        <span class="cov0" title="0">matches = append(matches, fullPath)</span>
                }
        }

        <span class="cov0" title="0">if len(matches) == 0 &amp;&amp; base != "" </span><span class="cov0" title="0">{
                pattern := filepath.Join(dir, base+"*")
                globMatches, err := filepath.Glob(pattern)
                if err == nil </span><span class="cov0" title="0">{
                        for _, match := range globMatches </span><span class="cov0" title="0">{
                                info, err := os.Stat(match)
                                if err == nil </span><span class="cov0" title="0">{
                                        if info.IsDir() </span><span class="cov0" title="0">{
                                                match += "/"
                                        }</span>
                                        <span class="cov0" title="0">matches = append(matches, match)</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return matches</span>
}

func (ce *CompletionEngine) ApplyCompletion(input string, cursorPos int, completion string) (string, int) <span class="cov0" title="0">{
        if cursorPos &gt; len(input) </span><span class="cov0" title="0">{
                cursorPos = len(input)
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(input, "/") </span><span class="cov0" title="0">{
                parts := strings.Fields(input)
                
                // Command completion (no space after command yet)
                if len(parts) &lt;= 1 &amp;&amp; !strings.Contains(input, " ") </span><span class="cov0" title="0">{
                        newInput := completion + " "
                        return newInput, len(completion) + 1
                }</span>

                // File path completion - find the current word and replace it
                <span class="cov0" title="0">currentWord, wordStart := ce.getCurrentWord(input, cursorPos)
                if wordStart &gt;= 0 </span><span class="cov0" title="0">{
                        // Replace the current word with the completion
                        before := input[:wordStart]
                        after := ""
                        
                        // Find where current word ends
                        wordEnd := wordStart + len(currentWord)
                        if wordEnd &lt; len(input) </span><span class="cov0" title="0">{
                                after = input[wordEnd:]
                        }</span>
                        
                        <span class="cov0" title="0">newInput := before + completion + after
                        newCursorPos := wordStart + len(completion)
                        return newInput, newCursorPos</span>
                }
        }

        <span class="cov0" title="0">return completion, len(completion)</span>
}

func (ce *CompletionEngine) GetCommonPrefix(completions []string) string <span class="cov0" title="0">{
        if len(completions) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(completions) == 1 </span><span class="cov0" title="0">{
                return completions[0]
        }</span>

        <span class="cov0" title="0">prefix := completions[0]
        for _, comp := range completions[1:] </span><span class="cov0" title="0">{
                for !strings.HasPrefix(comp, prefix) &amp;&amp; len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                        prefix = prefix[:len(prefix)-1]
                }</span>
                <span class="cov0" title="0">if prefix == "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        
        <span class="cov0" title="0">return prefix</span>
}

// getCurrentWord finds the word being typed at the cursor position
func (ce *CompletionEngine) getCurrentWord(input string, cursorPos int) (string, int) <span class="cov8" title="1">{
        if cursorPos &gt; len(input) </span><span class="cov0" title="0">{
                cursorPos = len(input)
        }</span>

        // Find word boundaries around cursor
        <span class="cov8" title="1">wordStart := cursorPos
        wordEnd := cursorPos

        // Find start of current word (go backwards until space or start)
        for wordStart &gt; 0 &amp;&amp; input[wordStart-1] != ' ' </span><span class="cov0" title="0">{
                wordStart--
        }</span>

        // Find end of current word (go forwards until space or end)
        <span class="cov8" title="1">for wordEnd &lt; len(input) &amp;&amp; input[wordEnd] != ' ' </span><span class="cov0" title="0">{
                wordEnd++
        }</span>

        // Return the current word and its start position
        <span class="cov8" title="1">if wordStart &lt; len(input) </span><span class="cov0" title="0">{
                return input[wordStart:wordEnd], wordStart
        }</span>

        <span class="cov8" title="1">return "", wordStart</span>
}

// completeConfigSubcommands returns available config subcommands
func (ce *CompletionEngine) completeConfigSubcommands(prefix string) []string <span class="cov0" title="0">{
        subcommands := []string{
                "show", "init", "get", "set",
                "model", "temperature", "max-tokens", "help",
        }

        var matches []string
        for _, subcmd := range subcommands </span><span class="cov0" title="0">{
                if strings.HasPrefix(subcmd, prefix) </span><span class="cov0" title="0">{
                        matches = append(matches, subcmd)
                }</span>
        }
        <span class="cov0" title="0">return matches</span>
}

// completeConfigKeys returns available configuration keys
func (ce *CompletionEngine) completeConfigKeys(prefix string) []string <span class="cov0" title="0">{
        keys := []string{
                "api-key", "model", "temperature", "max-tokens",
        }

        var matches []string
        for _, key := range keys </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, prefix) </span><span class="cov0" title="0">{
                        matches = append(matches, key)
                }</span>
        }
        <span class="cov0" title="0">return matches</span>
}

// completeModels returns available model names
func (ce *CompletionEngine) completeModels(prefix string) []string <span class="cov0" title="0">{
        models := []string{
                "deepseek-chat", "deepseek-reasoner",
        }

        var matches []string
        for _, model := range models </span><span class="cov0" title="0">{
                if strings.HasPrefix(model, prefix) </span><span class="cov0" title="0">{
                        matches = append(matches, model)
                }</span>
        }
        <span class="cov0" title="0">return matches</span>
}

// completeConfigValues suggests values based on the config key
func (ce *CompletionEngine) completeConfigValues(key, prefix string) []string <span class="cov0" title="0">{
        switch key </span>{
        case "model":<span class="cov0" title="0">
                return ce.completeModels(prefix)</span>
        case "temperature":<span class="cov0" title="0">
                values := []string{"0.1", "0.3", "0.5", "0.7", "1.0", "1.5"}
                var matches []string
                for _, val := range values </span><span class="cov0" title="0">{
                        if strings.HasPrefix(val, prefix) </span><span class="cov0" title="0">{
                                matches = append(matches, val)
                        }</span>
                }
                <span class="cov0" title="0">return matches</span>
        case "max-tokens":<span class="cov0" title="0">
                values := []string{"1024", "2048", "4096", "8192"}
                var matches []string
                for _, val := range values </span><span class="cov0" title="0">{
                        if strings.HasPrefix(val, prefix) </span><span class="cov0" title="0">{
                                matches = append(matches, val)
                        }</span>
                }
                <span class="cov0" title="0">return matches</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package input

import (
        "fmt"
        "github.com/antenore/deecli/internal/history"
        "github.com/charmbracelet/bubbles/textarea"
)

// Manager handles input history navigation and completion state
type Manager struct {
        // History navigation
        inputHistory  []string
        historyIndex  int
        tempInput     string
        historyMgr    *history.Manager

        // Completion state
        completions         []string
        showCompletions     bool
        completionIndex     int
        originalInput       string
        completionBaseInput string

        // Dependencies
        completionEngine CompletionEngine
        messageLogger    func(string, string)
        refreshViewport  func()
}

// CompletionEngine interface for completion functionality
type CompletionEngine interface {
        Complete(input string, cursorPos int) ([]string, string)
        ApplyCompletion(baseInput string, cursorPos int, completion string) (string, int)
}

// NewManager creates a new input manager
func NewManager(historyData []string, historyMgr *history.Manager, completionEngine CompletionEngine, messageLogger func(string, string), refreshViewport func()) *Manager <span class="cov8" title="1">{
        return &amp;Manager{
                inputHistory:     historyData,
                historyIndex:     -1,
                historyMgr:       historyMgr,
                completionEngine: completionEngine,
                messageLogger:    messageLogger,
                refreshViewport:  refreshViewport,
        }
}</span>

// HandleHistoryBack navigates backward in history
func (m *Manager) HandleHistoryBack(textarea *textarea.Model) bool <span class="cov8" title="1">{
        if len(m.inputHistory) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Save current input if starting history navigation
        <span class="cov8" title="1">if m.historyIndex == -1 </span><span class="cov8" title="1">{
                m.tempInput = textarea.Value()
        }</span>

        // Move backward in history
        <span class="cov8" title="1">if m.historyIndex &lt; len(m.inputHistory)-1 </span><span class="cov8" title="1">{
                m.historyIndex++
                textarea.SetValue(m.inputHistory[len(m.inputHistory)-1-m.historyIndex])
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// HandleHistoryForward navigates forward in history
func (m *Manager) HandleHistoryForward(textarea *textarea.Model) bool <span class="cov8" title="1">{
        if m.historyIndex &lt;= -1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">m.historyIndex--

        if m.historyIndex == -1 </span><span class="cov8" title="1">{
                // Restore original input
                textarea.SetValue(m.tempInput)
        }</span> else<span class="cov8" title="1"> {
                // Show history item
                textarea.SetValue(m.inputHistory[len(m.inputHistory)-1-m.historyIndex])
        }</span>
        <span class="cov8" title="1">return true</span>
}

// AddToHistory adds a new entry to input history
func (m *Manager) AddToHistory(input string) <span class="cov8" title="1">{
        m.inputHistory = append(m.inputHistory, input)
        m.historyIndex = -1
        m.tempInput = ""

        // Persist to disk if manager available
        if m.historyMgr != nil </span><span class="cov0" title="0">{
                m.historyMgr.Add(input)
        }</span>
}

// ShowHistory displays the command history
func (m *Manager) ShowHistory() <span class="cov0" title="0">{
        m.messageLogger("system", "üìú Command History:")

        if len(m.inputHistory) == 0 </span><span class="cov0" title="0">{
                m.messageLogger("system", "  No history yet")
                m.refreshViewport()
                return
        }</span>

        // Show last 20 entries to avoid overwhelming the display
        <span class="cov0" title="0">start := 0
        if len(m.inputHistory) &gt; 20 </span><span class="cov0" title="0">{
                start = len(m.inputHistory) - 20
                m.messageLogger("system", fmt.Sprintf("  Showing last 20 of %d entries:", len(m.inputHistory)))
        }</span> else<span class="cov0" title="0"> {
                m.messageLogger("system", fmt.Sprintf("  %d entries:", len(m.inputHistory)))
        }</span>

        <span class="cov0" title="0">for i := start; i &lt; len(m.inputHistory); i++ </span><span class="cov0" title="0">{
                entry := m.inputHistory[i]
                // Truncate long entries
                if len(entry) &gt; 80 </span><span class="cov0" title="0">{
                        entry = entry[:77] + "..."
                }</span>
                <span class="cov0" title="0">m.messageLogger("system", fmt.Sprintf("  %d. %s", i+1, entry))</span>
        }

        <span class="cov0" title="0">historyFile := "in-memory only"
        if m.historyMgr != nil </span><span class="cov0" title="0">{
                historyFile = ".deecli/history.jsonl"
        }</span>
        <span class="cov0" title="0">m.messageLogger("system", fmt.Sprintf("  History file: %s", historyFile))
        m.refreshViewport()</span>
}

// HandleTabCompletion initiates tab completion
func (m *Manager) HandleTabCompletion(input string) bool <span class="cov8" title="1">{
        cursorPos := len(input)
        completions, originalText := m.completionEngine.Complete(input, cursorPos)

        if len(completions) &gt; 0 </span><span class="cov8" title="1">{
                m.showCompletions = true
                m.completions = completions
                m.completionIndex = 0
                m.originalInput = originalText
                m.completionBaseInput = input
                return true
        }</span> else<span class="cov0" title="0"> {
                m.ClearCompletions()
                return false
        }</span>
}

// HandleCompletionNavigation handles up/down navigation in completions
func (m *Manager) HandleCompletionNavigation(direction string, textarea *textarea.Model) bool <span class="cov8" title="1">{
        if !m.showCompletions || len(m.completions) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">switch direction </span>{
        case "down", "ctrl+n":<span class="cov8" title="1">
                m.completionIndex = (m.completionIndex + 1) % len(m.completions)
                m.updateCompletionPreview(textarea)</span>
        case "up", "ctrl+p":<span class="cov8" title="1">
                if m.completionIndex == 0 </span><span class="cov8" title="1">{
                        m.completionIndex = len(m.completions) - 1
                }</span> else<span class="cov8" title="1"> {
                        m.completionIndex--
                }</span>
                <span class="cov8" title="1">m.updateCompletionPreview(textarea)</span>
        }
        <span class="cov8" title="1">return true</span>
}

// AcceptCompletion applies the current completion
func (m *Manager) AcceptCompletion(textarea *textarea.Model) bool <span class="cov0" title="0">{
        if !m.showCompletions || m.completionIndex &gt;= len(m.completions) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">completion := m.completions[m.completionIndex]
        baseInput := m.completionBaseInput
        newInput, _ := m.completionEngine.ApplyCompletion(baseInput, len(baseInput), completion)
        textarea.SetValue(newInput)

        m.ClearCompletions()
        return true</span>
}

// ClearCompletions clears completion state
func (m *Manager) ClearCompletions() <span class="cov8" title="1">{
        m.showCompletions = false
        m.completions = nil
        m.completionIndex = 0
        m.completionBaseInput = ""
}</span>

// GetCompletionState returns current completion state
func (m *Manager) GetCompletionState() ([]string, int, bool) <span class="cov8" title="1">{
        return m.completions, m.completionIndex, m.showCompletions
}</span>

// GetInputHistory returns the current input history
func (m *Manager) GetInputHistory() []string <span class="cov8" title="1">{
        return m.inputHistory
}</span>

// GetHistoryManager returns the history manager for persistence operations
func (m *Manager) GetHistoryManager() *history.Manager <span class="cov0" title="0">{
        return m.historyMgr
}</span>

// updateCompletionPreview updates the textarea with completion preview
func (m *Manager) updateCompletionPreview(textarea *textarea.Model) <span class="cov8" title="1">{
        if m.completionIndex &lt; len(m.completions) </span><span class="cov8" title="1">{
                completion := m.completions[m.completionIndex]
                baseInput := m.completionBaseInput
                cursorPos := len(baseInput)
                previewText, _ := m.completionEngine.ApplyCompletion(baseInput, cursorPos, completion)
                textarea.SetValue(previewText)
        }</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package keydetect

import (
        "fmt"

        "github.com/charmbracelet/bubbles/textarea"
        tea "github.com/charmbracelet/bubbletea"
)

// Dependencies defines the dependencies for the key detector
type Dependencies struct {
        ConfigManager  ConfigManager
        MessageLogger  func(msgType, content string)
        RefreshView    func()
        LayoutManager  LayoutManager
        UpdateKeymap   func() // Callback to update textarea keymap after config change
}

// ConfigManager defines methods needed from config
type ConfigManager interface {
        GetNewlineKey() string
        GetHistoryBackKey() string
        GetHistoryForwardKey() string
        SetNewlineKey(key string) error
        SetHistoryBackKey(key string) error
        SetHistoryForwardKey(key string) error
}

// LayoutManager defines methods needed from layout
type LayoutManager interface {
        FormatKeyForDisplay(key string) string
}

// Detector handles key detection and configuration
type Detector struct {
        deps             Dependencies
        detectionMode    bool
        detectionType    string
}

// New creates a new key detector
func New(deps Dependencies) *Detector <span class="cov0" title="0">{
        return &amp;Detector{
                deps: deps,
        }
}</span>

// IsDetecting returns true if in key detection mode
func (d *Detector) IsDetecting() bool <span class="cov0" title="0">{
        return d.detectionMode
}</span>

// GetDetectionType returns the current detection type
func (d *Detector) GetDetectionType() string <span class="cov0" title="0">{
        return d.detectionType
}</span>

// SetDetection sets the detection mode and type
func (d *Detector) SetDetection(enabled bool, keyType string) <span class="cov0" title="0">{
        d.detectionMode = enabled
        d.detectionType = keyType
}</span>

// StartDetection enters key detection mode to capture a specific key type
func (d *Detector) StartDetection(keyType string) <span class="cov0" title="0">{
        d.detectionMode = true
        d.detectionType = keyType

        switch keyType </span>{
        case "newline":<span class="cov0" title="0">
                d.deps.MessageLogger("system", "üéØ Key Detection Mode - Newline")
                d.deps.MessageLogger("system", "Press your preferred key combination for newlines (usually Ctrl+Enter)")</span>
        case "history-back":<span class="cov0" title="0">
                d.deps.MessageLogger("system", "üéØ Key Detection Mode - History Back")
                d.deps.MessageLogger("system", "Press your preferred key for previous history (default: Ctrl+P)")</span>
        case "history-forward":<span class="cov0" title="0">
                d.deps.MessageLogger("system", "üéØ Key Detection Mode - History Forward")
                d.deps.MessageLogger("system", "Press your preferred key for next history (default: Ctrl+N)")</span>
        }
        <span class="cov0" title="0">d.deps.MessageLogger("system", "Press Escape to cancel")
        d.deps.RefreshView()</span>
}

// ShowKeyBindings displays current key bindings
func (d *Detector) ShowKeyBindings() <span class="cov0" title="0">{
        d.deps.MessageLogger("system", "üéπ Current Key Bindings:")

        if d.deps.ConfigManager != nil </span><span class="cov0" title="0">{
                newlineKey := d.deps.LayoutManager.FormatKeyForDisplay(d.deps.ConfigManager.GetNewlineKey())
                historyBackKey := d.deps.LayoutManager.FormatKeyForDisplay(d.deps.ConfigManager.GetHistoryBackKey())
                historyForwardKey := d.deps.LayoutManager.FormatKeyForDisplay(d.deps.ConfigManager.GetHistoryForwardKey())

                d.deps.MessageLogger("system", fmt.Sprintf("  ‚Ä¢ Newline:         %s", newlineKey))
                d.deps.MessageLogger("system", fmt.Sprintf("  ‚Ä¢ History Back:    %s", historyBackKey))
                d.deps.MessageLogger("system", fmt.Sprintf("  ‚Ä¢ History Forward: %s", historyForwardKey))
        }</span> else<span class="cov0" title="0"> {
                d.deps.MessageLogger("system", "  ‚Ä¢ Newline:         Ctrl+J (default)")
                d.deps.MessageLogger("system", "  ‚Ä¢ History Back:    Ctrl+P (default)")
                d.deps.MessageLogger("system", "  ‚Ä¢ History Forward: Ctrl+N (default)")
        }</span>

        <span class="cov0" title="0">d.deps.MessageLogger("system", "")
        d.deps.MessageLogger("system", "To change a key binding:")
        d.deps.MessageLogger("system", "  /keysetup newline        - Configure newline key")
        d.deps.MessageLogger("system", "  /keysetup history-back   - Configure history back key")
        d.deps.MessageLogger("system", "  /keysetup history-forward - Configure history forward key")
        d.deps.RefreshView()</span>
}

// HandleDetection processes keys during key detection mode
func (d *Detector) HandleDetection(keyStr string) tea.Cmd <span class="cov0" title="0">{
        if keyStr == "esc" </span><span class="cov0" title="0">{
                d.detectionMode = false
                d.deps.MessageLogger("system", "‚ùå Key detection cancelled")
                d.deps.RefreshView()
                return nil
        }</span>

        // Detect if user pressed Enter when trying to press Ctrl+Enter
        <span class="cov0" title="0">if keyStr == "enter" </span><span class="cov0" title="0">{
                d.deps.MessageLogger("system", "üö® Terminal Limitation Detected!")
                d.deps.MessageLogger("system", "Your terminal sends the same code for Enter and Ctrl+Enter.")
                d.deps.MessageLogger("system", "This is common in many terminals. Let's try a key that actually works:")
                d.deps.MessageLogger("system", "")
                d.deps.MessageLogger("system", "Please try one of these alternatives:")
                d.deps.MessageLogger("system", "  ‚Ä¢ Press Ctrl+J (this usually works)")
                d.deps.MessageLogger("system", "  ‚Ä¢ Press Ctrl+M (another alternative)")
                d.deps.MessageLogger("system", "  ‚Ä¢ Press Alt+Enter (if your terminal supports it)")
                d.deps.MessageLogger("system", "")
                d.deps.MessageLogger("system", "Or press Escape to cancel and use the default (Ctrl+J)")
                d.deps.RefreshView()
                return nil // Stay in detection mode
        }</span>

        // Ignore common keys we don't want to capture
        <span class="cov0" title="0">ignored := []string{"up", "down", "left", "right", "home", "end", "pgup", "pgdown",
                                           "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12",
                                           "tab", "shift+tab", "alt", "ctrl", "shift"}
        for _, ignore := range ignored </span><span class="cov0" title="0">{
                if keyStr == ignore </span><span class="cov0" title="0">{
                        return nil // Don't capture these keys
                }</span>
        }

        // Filter out problematic key combinations that add unwanted characters
        <span class="cov0" title="0">problematic := []string{"alt+o", "alt+O", "alt+m", "alt+M"}
        for _, prob := range problematic </span><span class="cov0" title="0">{
                if keyStr == prob </span><span class="cov0" title="0">{
                        d.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Key %s detected, but it adds extra characters to input!", keyStr))
                        d.deps.MessageLogger("system", "This happens with some Alt+ combinations in certain terminals.")
                        d.deps.MessageLogger("system", "")
                        d.deps.MessageLogger("system", "Please try a reliable alternative:")
                        d.deps.MessageLogger("system", "  ‚Ä¢ Ctrl+J (most reliable)")
                        d.deps.MessageLogger("system", "  ‚Ä¢ Ctrl+M (alternative)")
                        d.deps.MessageLogger("system", "")
                        d.deps.MessageLogger("system", "Or press Escape to use default (Ctrl+J)")
                        d.deps.RefreshView()
                        return nil // Stay in detection mode
                }</span>
        }

        // Different validation based on key type
        <span class="cov0" title="0">var validKeys []string
        var defaultKey string

        switch d.detectionType </span>{
        case "newline":<span class="cov0" title="0">
                validKeys = []string{"ctrl+j", "ctrl+m", "ctrl+k", "ctrl+l", "alt+enter"}
                defaultKey = "Ctrl+J"</span>
        case "history-back", "history-forward":<span class="cov0" title="0">
                // More keys are valid for history navigation
                validKeys = []string{"ctrl+p", "ctrl+n", "alt+up", "alt+down", "ctrl+up", "ctrl+down",
                                                        "ctrl+b", "ctrl+f", "alt+p", "alt+n", "ctrl+r", "ctrl+s"}
                if d.detectionType == "history-back" </span><span class="cov0" title="0">{
                        defaultKey = "Ctrl+P"
                }</span> else<span class="cov0" title="0"> {
                        defaultKey = "Ctrl+N"
                }</span>
        }

        <span class="cov0" title="0">isValid := false
        for _, valid := range validKeys </span><span class="cov0" title="0">{
                if keyStr == valid </span><span class="cov0" title="0">{
                        isValid = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !isValid &amp;&amp; d.detectionType == "newline" </span><span class="cov0" title="0">{
                d.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Key %s might not work reliably across all terminals.", keyStr))
                d.deps.MessageLogger("system", "For best compatibility, please use one of these tested keys:")
                d.deps.MessageLogger("system", "  ‚Ä¢ Ctrl+J (most reliable)")
                d.deps.MessageLogger("system", "  ‚Ä¢ Ctrl+M (alternative)")
                d.deps.MessageLogger("system", "")
                d.deps.MessageLogger("system", fmt.Sprintf("Or press Escape to use default (%s)", defaultKey))
                d.deps.RefreshView()
                return nil // Stay in detection mode
        }</span>

        // For history keys, accept more combinations but warn if unusual
        <span class="cov0" title="0">if !isValid &amp;&amp; (d.detectionType == "history-back" || d.detectionType == "history-forward") </span><span class="cov0" title="0">{
                // Accept it but warn
                d.deps.MessageLogger("system", fmt.Sprintf("‚ö†Ô∏è Key %s is non-standard but will be saved.", keyStr))
        }</span>

        // Capture the validated key
        <span class="cov0" title="0">d.detectionMode = false

        // Save to config based on type
        if d.deps.ConfigManager != nil </span><span class="cov0" title="0">{
                var err error
                switch d.detectionType </span>{
                case "newline":<span class="cov0" title="0">
                        err = d.deps.ConfigManager.SetNewlineKey(keyStr)</span>
                case "history-back":<span class="cov0" title="0">
                        err = d.deps.ConfigManager.SetHistoryBackKey(keyStr)</span>
                case "history-forward":<span class="cov0" title="0">
                        err = d.deps.ConfigManager.SetHistoryForwardKey(keyStr)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        d.deps.MessageLogger("system", fmt.Sprintf("‚ùå Failed to save key configuration: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        displayKey := d.deps.LayoutManager.FormatKeyForDisplay(keyStr)
                        switch d.detectionType </span>{
                        case "newline":<span class="cov0" title="0">
                                d.deps.MessageLogger("system", fmt.Sprintf("‚úÖ Newline key set to: %s", displayKey))
                                d.deps.MessageLogger("system", "üîÑ Updating textarea configuration...")</span>
                        case "history-back":<span class="cov0" title="0">
                                d.deps.MessageLogger("system", fmt.Sprintf("‚úÖ History back key set to: %s", displayKey))</span>
                        case "history-forward":<span class="cov0" title="0">
                                d.deps.MessageLogger("system", fmt.Sprintf("‚úÖ History forward key set to: %s", displayKey))</span>
                        }

                        // Update textarea keymap if it's a newline key change
                        <span class="cov0" title="0">if d.detectionType == "newline" &amp;&amp; d.deps.UpdateKeymap != nil </span><span class="cov0" title="0">{
                                d.deps.UpdateKeymap()
                        }</span>

                        <span class="cov0" title="0">d.deps.MessageLogger("system", "‚úÖ Configuration updated! Try your new key combination.")</span>
                }
        } else<span class="cov0" title="0"> {
                d.deps.MessageLogger("system", "‚ùå Config manager not available")
        }</span>

        <span class="cov0" title="0">d.deps.RefreshView()
        return nil</span>
}

// UpdateTextareaKeymap updates the textarea keymap with the configured newline key
func (d *Detector) UpdateTextareaKeymap(textarea *textarea.Model) <span class="cov0" title="0">{
        if d.deps.ConfigManager != nil &amp;&amp; textarea != nil </span><span class="cov0" title="0">{
                newlineKey := d.deps.ConfigManager.GetNewlineKey()
                keyMap := textarea.KeyMap
                keyMap.InsertNewline.SetKeys(newlineKey)
                textarea.KeyMap = keyMap
        }</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package chat

import (
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/antenore/deecli/internal/ai"
        "github.com/antenore/deecli/internal/api"
        "github.com/antenore/deecli/internal/chat/commands"
        "github.com/antenore/deecli/internal/chat/input"
        "github.com/antenore/deecli/internal/chat/keydetect"
        "github.com/antenore/deecli/internal/chat/tracker"
        "github.com/antenore/deecli/internal/chat/ui"
        viewportmgr "github.com/antenore/deecli/internal/chat/viewport"
        "github.com/antenore/deecli/internal/config"
        "github.com/antenore/deecli/internal/editor"
        "github.com/antenore/deecli/internal/files"
        "github.com/antenore/deecli/internal/history"
        "github.com/antenore/deecli/internal/sessions"
        "github.com/antenore/deecli/internal/utils"
        "github.com/charmbracelet/bubbles/textarea"
        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// Custom message types for tea
// cancelApiMsg for cancelling ongoing API requests
type cancelApiMsg struct{}


// NewModel represents a clean chat interface using proper Bubbletea components
type NewModel struct {
        viewport         viewport.Model
        sidebarViewport  viewport.Model  // Separate viewport for sidebar
        textarea         textarea.Model  // Replace string input with textarea
        fileContext      *files.FileContext
        apiClient        *api.Service
        completionEngine *CompletionEngine
        configManager    *config.Manager // Config manager for proper config integration
        commandHandler   *commands.Handler // Command handler for chat commands
        renderer         *ui.Renderer    // UI renderer for message formatting
        layoutManager    *ui.Layout      // Layout manager for UI layout calculations
        sidebar          *ui.Sidebar     // Sidebar for files display
        aiOperations     *ai.Operations  // AI operations handler
        viewportManager  *viewportmgr.Manager // Viewport and message manager
        width            int
        height           int
        ready            bool
        helpVisible      bool
        filesWidgetVisible bool
        isLoading        bool
        loadingMsg       string
        focusMode        string // "input", "viewport", or "sidebar" - tracks which component has focus
        keyDetector      *keydetect.Detector // Key detection handler
        messages         []string // Keep track of all messages for full scrollback
        apiMessages      []api.Message // Keep chat history for API context
        sessionManager   *sessions.Manager
        currentSession   *sessions.Session
        sessionLoader    *sessions.Loader
        inputManager     *input.Manager // Input and history management
        apiCancel        context.CancelFunc // Function to cancel ongoing API request
        fileTracker      *tracker.FileTracker // Track files mentioned in AI responses

        // Streaming support
        streamingEnabled bool             // Whether to use streaming API
        streamReader     api.StreamReader // Current stream reader
        streamContent    string           // Accumulated stream content
}

// initializeComponents creates common components needed by both constructors
func initializeComponents(width, height int, client *api.Service, configManager *config.Manager) (*files.FileContext, *CompletionEngine, *ui.Renderer, *ui.Layout, *ui.Sidebar, *ai.Operations, *history.Manager, []string) <span class="cov8" title="1">{
        // Initialize history manager and load existing history
        historyMgr, err := history.NewManager()
        var historyData []string
        if err == nil &amp;&amp; historyMgr != nil </span><span class="cov8" title="1">{
                historyData, _ = historyMgr.Load()
        }</span>

        <span class="cov8" title="1">fileCtx := files.NewFileContext()
        completionEngine := NewCompletionEngine()
        renderer := ui.NewRenderer(configManager)
        layoutManager := ui.NewLayout(configManager)
        sidebar := ui.NewSidebar()
        aiOperations := ai.NewOperations(client, fileCtx)

        return fileCtx, completionEngine, renderer, layoutManager, sidebar, aiOperations, historyMgr, historyData</span>
}

// createTextarea creates and configures a textarea component
func createTextarea(width int) textarea.Model <span class="cov8" title="1">{
        ta := textarea.New()
        ta.Placeholder = "Type your message... (Enter to send, Ctrl+Enter for new line)"
        ta.ShowLineNumbers = false
        ta.SetHeight(3)
        ta.SetWidth(width - 4)
        ta.CharLimit = 0
        ta.Focus()
        ta.Prompt = "‚îÉ "

        // Customize KeyMap: Use default fallback key for newlines
        // Will be updated by updateTextareaKeymap() if config is available
        keyMap := textarea.DefaultKeyMap
        keyMap.InsertNewline.SetKeys("ctrl+j") // Default fallback
        ta.KeyMap = keyMap

        return ta
}</span>

func newChatModel() *NewModel <span class="cov8" title="1">{
        return newChatModelInternal(nil, "", "", 0, 0)
}</span>

func newChatModelWithConfig(configManager *config.Manager, apiKey, model string, temperature float64, maxTokens int) *NewModel <span class="cov8" title="1">{
        return newChatModelInternal(configManager, apiKey, model, temperature, maxTokens)
}</span>

// createAPIClient creates API client with fallback to environment variables
func createAPIClient(configManager *config.Manager, apiKey, model string, temperature float64, maxTokens int) *api.Service <span class="cov8" title="1">{
        if apiKey != "" </span><span class="cov0" title="0">{
                return api.NewDeepSeekService(apiKey, model, temperature, maxTokens)
        }</span>

        // Use environment variable fallback for simple constructor
        <span class="cov8" title="1">envApiKey := os.Getenv("DEEPSEEK_API_KEY")
        if envApiKey != "" </span><span class="cov0" title="0">{
                return api.NewDeepSeekService(envApiKey, "deepseek-chat", 0.1, 2048)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// newChatModelInternal is the consolidated constructor implementation
func newChatModelInternal(configManager *config.Manager, apiKey, model string, temperature float64, maxTokens int) *NewModel <span class="cov8" title="1">{
        client := createAPIClient(configManager, apiKey, model, temperature, maxTokens)

        // Initialize session manager (only for config-based constructor)
        var sessionMgr *sessions.Manager
        var currentSession *sessions.Session
        if configManager != nil </span><span class="cov0" title="0">{
                var err error
                sessionMgr, err = sessions.NewManager()
                if err == nil &amp;&amp; sessionMgr != nil </span><span class="cov0" title="0">{
                        currentSession, _ = sessionMgr.GetCurrentSession()
                }</span>
        }

        // Get terminal size
        <span class="cov8" title="1">width, height := utils.GetTerminalSize()

        // Initialize textarea for multi-line input
        ta := createTextarea(width)

        // Initialize common components
        fileCtx, completionEngine, renderer, layoutManager, sidebar, aiOperations, historyMgr, historyData := initializeComponents(width, height, client, configManager)

        chatModel := &amp;NewModel{
                textarea:         ta,
                fileContext:      fileCtx,
                apiClient:        client,
                completionEngine: completionEngine,
                configManager:    configManager,
                renderer:         renderer,
                layoutManager:    layoutManager,
                sidebar:          sidebar,
                aiOperations:     aiOperations,
                width:            width,
                height:           height,
                focusMode:        "input", // Start with input focused
                messages:         []string{}, // Initialize message history
                apiMessages:      []api.Message{}, // Initialize API message history
                sessionManager:   sessionMgr,
                currentSession:   currentSession,
                fileTracker:      tracker.NewFileTracker(), // Initialize file tracker
                streamingEnabled: true, // Enable streaming by default
        }

        // Initialize input manager
        chatModel.inputManager = input.NewManager(
                historyData,
                historyMgr,
                chatModel.completionEngine,
                chatModel.addMessage,
                chatModel.refreshViewport,
        )

        // Initialize key detector (only if config is provided)
        if configManager != nil </span><span class="cov0" title="0">{
                chatModel.keyDetector = keydetect.New(keydetect.Dependencies{
                        ConfigManager:  configManager,
                        MessageLogger:  chatModel.addMessage,
                        RefreshView:    chatModel.refreshViewport,
                        LayoutManager:  chatModel.layoutManager,
                        UpdateKeymap:   func() </span><span class="cov0" title="0">{ chatModel.keyDetector.UpdateTextareaKeymap(&amp;chatModel.textarea) }</span>,
                })

                // Update textarea keymap with configured newline key
                <span class="cov0" title="0">chatModel.keyDetector.UpdateTextareaKeymap(&amp;chatModel.textarea)</span>
        }

        // Initialize command handler with dependencies
        <span class="cov8" title="1">chatModel.commandHandler = commands.NewHandler(chatModel.createCommandDependencies())

        // Initialize session loader with dependencies (only if session exists)
        if sessionMgr != nil &amp;&amp; currentSession != nil </span><span class="cov0" title="0">{
                chatModel.sessionLoader = sessions.NewLoader(&amp;sessions.LoaderDependencies{
                        SessionManager:       sessionMgr,
                        CurrentSession:       currentSession,
                        Renderer:            chatModel.renderer,
                        Viewport:            &amp;chatModel.viewport,
                        ViewportWidth:       chatModel.viewport.Width,
                        FilesWidgetVisible:  chatModel.filesWidgetVisible,
                        FormatInitialContent: func() string </span><span class="cov0" title="0">{
                                if chatModel.viewportManager != nil </span><span class="cov0" title="0">{
                                        return chatModel.viewportManager.FormatInitialContent()
                                }</span>
                                <span class="cov0" title="0">return "Welcome to DeeCLI"</span>
                        },
                })
        }

        <span class="cov8" title="1">return chatModel</span>
}

// getHistoryManager returns the history manager from input manager
func (m *NewModel) getHistoryManager() *history.Manager <span class="cov8" title="1">{
        if m.inputManager != nil </span><span class="cov8" title="1">{
                return m.inputManager.GetHistoryManager()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// createCommandDependencies creates Dependencies struct for command handlers
func (m *NewModel) createCommandDependencies() commands.Dependencies <span class="cov8" title="1">{
        var inputHistory []string
        if m.inputManager != nil </span><span class="cov8" title="1">{
                inputHistory = m.inputManager.GetInputHistory()
        }</span>

        <span class="cov8" title="1">return commands.Dependencies{
                FileContext:      m.fileContext,
                APIClient:        m.apiClient,
                ConfigManager:    m.configManager,
                SessionManager:   m.sessionManager,
                CurrentSession:   m.currentSession,
                HistoryManager:   m.getHistoryManager(),
                FileTracker:      m.fileTracker,
                Messages:         m.messages,
                APIMessages:      m.apiMessages,
                InputHistory:     inputHistory,
                HelpVisible:      m.helpVisible,
                MessageLogger:    m.addMessage,
                SetLoading:       m.setLoading,
                SetCancel:        m.setCancel,
                RefreshUI:        m.refreshViewport,
                ShowHistory:      m.showHistoryFromInputManager,
                AnalyzeFiles:     m.analyzeFiles,
                ExplainFiles:     m.explainFiles,
                ImproveFiles:     m.improveFiles,
                GenerateEditSuggestions: m.generateEditSuggestions,
                SetHelpVisible:   m.setHelpVisible,
                SetKeyDetection:  m.keyDetector.SetDetection,
        }</span>
}

// Helper methods for command dependencies
func (m *NewModel) showHistoryFromInputManager() <span class="cov0" title="0">{
        if m.inputManager != nil </span><span class="cov0" title="0">{
                m.inputManager.ShowHistory()
        }</span>
}

func (m *NewModel) setLoading(loading bool, message string) <span class="cov0" title="0">{
        m.isLoading = loading
        m.loadingMsg = message
}</span>

func (m *NewModel) setCancel(cancel context.CancelFunc) <span class="cov0" title="0">{
        m.apiCancel = cancel
}</span>

func (m *NewModel) setHelpVisible(visible bool) <span class="cov0" title="0">{
        m.helpVisible = visible
        if m.helpVisible </span><span class="cov0" title="0">{
                if m.viewportManager != nil </span><span class="cov0" title="0">{
                        m.viewport.SetContent(m.viewportManager.HelpContent())
                }</span> else<span class="cov0" title="0"> {
                        m.viewport.SetContent("Help not available")
                }</span>
        } else<span class="cov0" title="0"> {
                m.refreshViewport()
        }</span>
}


func (m NewModel) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>




func (m *NewModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmd tea.Cmd
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                
                if !m.ready </span><span class="cov0" title="0">{
                        // Initialize viewports with proper size and positioning
                        m.viewport = viewport.New(m.width, 10) // Initial size, will be set by layout
                        m.viewport.YPosition = 1  // Start after header line

                        // Initialize sidebar viewport
                        m.sidebarViewport = viewport.New(25, 10) // Initial size, will be set by layout
                        m.sidebarViewport.YPosition = 1  // Start after header line

                        // Set proper layout (this will correct the sizes and positions)
                        m.layout()

                        // Initialize viewport manager now that viewport is properly set up
                        if m.viewportManager == nil </span><span class="cov0" title="0">{
                                m.viewportManager = viewportmgr.NewManager(viewportmgr.Dependencies{
                                        Viewport:         &amp;m.viewport,
                                        Renderer:         m.renderer,
                                        LayoutManager:    m.layoutManager,
                                        ConfigManager:    m.configManager,
                                        SessionManager:   m.sessionManager,
                                        CurrentSession:   m.currentSession,
                                        Messages:         &amp;m.messages,
                                        APIMessages:      &amp;m.apiMessages,
                                        FilesWidgetVisible: &amp;m.filesWidgetVisible,
                                        IsLoading:        &amp;m.isLoading,
                                        LoadingMsg:       &amp;m.loadingMsg,
                                })
                        }</span>

                        // Add welcome message to history
                        <span class="cov0" title="0">if m.viewportManager != nil </span><span class="cov0" title="0">{
                                m.messages = append(m.messages, m.viewportManager.FormatInitialContent())
                        }</span> else<span class="cov0" title="0"> {
                                m.messages = append(m.messages, "Welcome to DeeCLI")
                        }</span>
                        <span class="cov0" title="0">m.viewport.SetContent(strings.Join(m.messages, "\n\n"))
                        m.ready = true</span>
                } else<span class="cov0" title="0"> {
                        // Update viewport width and recalculate layout
                        m.viewport.Width = m.width
                        m.layout()
                }</span>

        case cancelApiMsg:<span class="cov0" title="0">
                m.isLoading = false
                m.loadingMsg = ""
                m.apiCancel = nil
                // Close stream reader if active
                if m.streamReader != nil </span><span class="cov0" title="0">{
                        m.streamReader.Close()
                        m.streamReader = nil
                        m.streamContent = ""
                }</span>
                <span class="cov0" title="0">m.addMessage("system", "üö´ Request cancelled")
                m.viewport.GotoBottom()</span>

        case ai.APIResponseMsg:<span class="cov0" title="0">
                m.handleAPIResponse(msg.Response, msg.Err)</span>

        case ai.StreamStartedMsg:<span class="cov0" title="0">
                // Stream has started, save the reader and start reading chunks
                m.streamReader = msg.Stream
                m.streamContent = ""
                m.isLoading = true  // Set loading flag for streaming
                // Add initial placeholder assistant message - this will be updated during streaming
                m.messages = append(m.messages, m.renderer.FormatMessage("assistant", ""))
                m.viewport.SetContent(strings.Join(m.messages, "\n\n"))
                m.viewport.GotoBottom()
                // Start reading the first chunk
                return m, ai.ReadNextChunk(msg.Stream, m.streamContent)</span>

        case ai.StreamChunkMsg:<span class="cov0" title="0">
                // Handle incoming chunk
                if msg.Err != nil </span><span class="cov0" title="0">{
                        m.handleStreamComplete(m.streamContent, msg.Err)
                        return m, nil
                }</span>

                // Append chunk content
                <span class="cov0" title="0">m.streamContent += msg.Content

                // Update the display with accumulated content
                m.updateStreamingDisplay(m.streamContent)

                // Continue reading next chunk
                if m.streamReader != nil </span><span class="cov0" title="0">{
                        return m, ai.ReadNextChunk(m.streamReader, m.streamContent)
                }</span>

        case ai.StreamCompleteMsg:<span class="cov0" title="0">
                // Stream completed
                m.handleStreamComplete(msg.TotalContent, msg.Err)</span>

        case editor.EditorFinishedMsg:<span class="cov0" title="0">
                if msg.Error != nil </span><span class="cov0" title="0">{
                        m.addMessage("system", fmt.Sprintf("‚ùå Editor error: %v", msg.Error))
                }</span> else<span class="cov0" title="0"> {
                        m.addMessage("system", "‚úì Editor closed")
                        
                        // Auto-reload any files that are currently loaded to pick up changes
                        if len(m.fileContext.Files) &gt; 0 </span><span class="cov0" title="0">{
                                results, err := m.fileContext.ReloadFiles(nil) // Reload all loaded files
                                if err != nil </span><span class="cov0" title="0">{
                                        m.addMessage("system", fmt.Sprintf("‚ö†Ô∏è Failed to auto-reload files: %v", err))
                                }</span> else<span class="cov0" title="0"> if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                        changedCount := 0
                                        for _, result := range results </span><span class="cov0" title="0">{
                                                if result.Status == "changed" </span><span class="cov0" title="0">{
                                                        changedCount++
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if changedCount &gt; 0 </span><span class="cov0" title="0">{
                                                m.addMessage("system", fmt.Sprintf("üîÑ Auto-reloaded %d file(s), %d changed", len(results), changedCount))
                                        }</span>
                                        
                                        // Update sidebar if visible
                                        <span class="cov0" title="0">if m.filesWidgetVisible </span><span class="cov0" title="0">{
                                                m.sidebarViewport.SetContent(m.renderFilesSidebar())
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">m.refreshViewport()</span>

        case tea.KeyMsg:<span class="cov8" title="1">
                // Handle key detection mode first (highest priority)
                if m.keyDetector != nil &amp;&amp; m.keyDetector.IsDetecting() </span><span class="cov0" title="0">{
                        return m, m.keyDetector.HandleDetection(msg.String())
                }</span>
                
                // First handle global keys that work regardless of focus
                <span class="cov8" title="1">switch msg.String() </span>{
                case "ctrl+c":<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case "esc":<span class="cov0" title="0">
                        // Cancel ongoing API request if one is active
                        if m.isLoading &amp;&amp; m.apiCancel != nil </span><span class="cov0" title="0">{
                                m.apiCancel()
                                m.apiCancel = nil
                                return m, func() tea.Msg </span><span class="cov0" title="0">{ return cancelApiMsg{} }</span>
                        }
                case "f1":<span class="cov0" title="0">
                        m.helpVisible = !m.helpVisible
                        if m.helpVisible </span><span class="cov0" title="0">{
                                if m.viewportManager != nil </span><span class="cov0" title="0">{
                                        m.viewport.SetContent(m.viewportManager.HelpContent())
                                }</span> else<span class="cov0" title="0"> {
                                        m.viewport.SetContent("Help not available")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                m.refreshViewport()
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "f2":<span class="cov0" title="0">
                        m.filesWidgetVisible = !m.filesWidgetVisible
                        if m.filesWidgetVisible </span><span class="cov0" title="0">{
                                m.sidebarViewport.SetContent(m.renderFilesSidebar())
                                m.sidebarViewport.GotoTop()
                        }</span>
                        <span class="cov0" title="0">m.layout()
                        return m, nil</span>
                // Removed ctrl+w interception - now it naturally deletes words in textarea
                }

                // Handle viewport scrolling when viewport has focus
                <span class="cov8" title="1">if m.focusMode == "viewport" </span><span class="cov8" title="1">{
                        switch msg.String() </span>{
                        case "up", "down", "pgup", "pgdown", "ctrl+u", "ctrl+d", "home", "end":<span class="cov8" title="1">
                                m.viewport, cmd = m.viewport.Update(msg)
                                cmds = append(cmds, cmd)
                                return m, tea.Batch(cmds...)</span>
                        case "tab":<span class="cov0" title="0">
                                // Continue focus cycle from viewport
                                if m.filesWidgetVisible </span><span class="cov0" title="0">{
                                        m.focusMode = "sidebar"
                                        m.sidebarViewport.GotoTop()
                                }</span> else<span class="cov0" title="0"> {
                                        m.focusMode = "input"
                                        m.textarea.Focus()
                                }</span>
                                <span class="cov0" title="0">return m, nil</span>
                        case "enter", "esc":<span class="cov0" title="0">
                                m.focusMode = "input"
                                m.textarea.Focus()
                                return m, nil</span>
                        }
                }

                // Handle sidebar scrolling
                <span class="cov8" title="1">if m.focusMode == "sidebar" </span><span class="cov8" title="1">{
                        switch msg.String() </span>{
                        case "up", "down", "pgup", "pgdown", "ctrl+u", "ctrl+d", "home", "end":<span class="cov8" title="1">
                                m.sidebarViewport, cmd = m.sidebarViewport.Update(msg)
                                cmds = append(cmds, cmd)
                                return m, tea.Batch(cmds...)</span>
                        case "tab":<span class="cov0" title="0">
                                // Complete focus cycle - back to input
                                m.focusMode = "input"
                                m.textarea.Focus()
                                return m, nil</span>
                        case "enter", "esc":<span class="cov0" title="0">
                                m.focusMode = "input"
                                m.textarea.Focus()
                                return m, nil</span>
                        }
                }

                // Input mode - handle special keys first, then let textarea handle the rest
                <span class="cov8" title="1">if m.focusMode == "input" </span><span class="cov8" title="1">{
                        // Handle completion navigation with arrow keys
                        if m.inputManager != nil </span><span class="cov8" title="1">{
                                completions, _, showCompletions := m.inputManager.GetCompletionState()
                                if showCompletions &amp;&amp; len(completions) &gt; 0 </span><span class="cov0" title="0">{
                                        switch msg.String() </span>{
                                        case "down", "ctrl+n":<span class="cov0" title="0">
                                                if m.inputManager.HandleCompletionNavigation("down", &amp;m.textarea) </span><span class="cov0" title="0">{
                                                        return m, nil
                                                }</span>
                                        case "up", "ctrl+p":<span class="cov0" title="0">
                                                if m.inputManager.HandleCompletionNavigation("up", &amp;m.textarea) </span><span class="cov0" title="0">{
                                                        return m, nil
                                                }</span>
                                        case "tab", "enter":<span class="cov0" title="0">
                                                if m.inputManager.AcceptCompletion(&amp;m.textarea) </span><span class="cov0" title="0">{
                                                        // If this was Enter, don't let it fall through to send message
                                                        if msg.String() == "enter" </span><span class="cov0" title="0">{
                                                                return m, nil
                                                        }</span>
                                                }
                                        case "esc":<span class="cov0" title="0">
                                                m.inputManager.ClearCompletions()
                                                return m, nil</span>
                                        }
                                } else<span class="cov8" title="1"> {
                                        // No completions shown - handle arrow keys for history navigation
                                        // Only use arrows for history if input is single-line
                                        currentInput := m.textarea.Value()
                                        isMultiLine := strings.Contains(currentInput, "\n")

                                        if !isMultiLine &amp;&amp; m.inputManager != nil </span><span class="cov8" title="1">{
                                                switch msg.String() </span>{
                                                case "up":<span class="cov8" title="1">
                                                        if m.inputManager.HandleHistoryBack(&amp;m.textarea) </span><span class="cov8" title="1">{
                                                                return m, nil
                                                        }</span>
                                                case "down":<span class="cov8" title="1">
                                                        if m.inputManager.HandleHistoryForward(&amp;m.textarea) </span><span class="cov8" title="1">{
                                                                return m, nil
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Smart Tab: completion if available, focus switch otherwise
                        // (Tab for accepting completions is already handled above when completions are shown)
                        <span class="cov8" title="1">if msg.String() == "tab" &amp;&amp; m.inputManager != nil </span><span class="cov0" title="0">{
                                input := m.textarea.Value()

                                // Try to show completions
                                if m.inputManager.HandleTabCompletion(input) </span><span class="cov0" title="0">{
                                        // Completions are now showing
                                        return m, nil
                                }</span>

                                // No completions available, use Tab for focus switching
                                <span class="cov0" title="0">switch m.focusMode </span>{
                                case "input":<span class="cov0" title="0">
                                        m.focusMode = "viewport"
                                        m.textarea.Blur()</span>
                                case "viewport":<span class="cov0" title="0">
                                        if m.filesWidgetVisible </span><span class="cov0" title="0">{
                                                m.focusMode = "sidebar"
                                                m.sidebarViewport.GotoTop()
                                        }</span> else<span class="cov0" title="0"> {
                                                m.focusMode = "input"
                                                m.textarea.Focus()
                                        }</span>
                                case "sidebar":<span class="cov0" title="0">
                                        m.focusMode = "input"
                                        m.textarea.Focus()</span>
                                default:<span class="cov0" title="0">
                                        m.focusMode = "input"
                                        m.textarea.Focus()</span>
                                }
                                <span class="cov0" title="0">return m, nil</span>
                        }
                        
                        // Handle history navigation BEFORE textarea gets the keys
                        <span class="cov8" title="1">historyHandled := false
                        if m.configManager != nil &amp;&amp; m.inputManager != nil </span><span class="cov0" title="0">{
                                historyBackKey := m.configManager.GetHistoryBackKey()
                                historyForwardKey := m.configManager.GetHistoryForwardKey()

                                switch msg.String() </span>{
                                case historyBackKey:<span class="cov0" title="0"> // Previous history (default ctrl+p)
                                        historyHandled = true
                                        if m.inputManager.HandleHistoryBack(&amp;m.textarea) </span><span class="cov0" title="0">{
                                                return m, nil
                                        }</span>

                                case historyForwardKey:<span class="cov0" title="0"> // Next history (default ctrl+n)
                                        historyHandled = true
                                        if m.inputManager.HandleHistoryForward(&amp;m.textarea) </span><span class="cov0" title="0">{
                                                return m, nil
                                        }</span>
                                }
                        }

                        // Clear completions on any other key (except history navigation)
                        <span class="cov8" title="1">if msg.String() != "tab" &amp;&amp; !historyHandled &amp;&amp; m.inputManager != nil </span><span class="cov8" title="1">{
                                m.inputManager.ClearCompletions()
                        }</span>

                        // Let textarea handle non-tab, non-history keys
                        <span class="cov8" title="1">if !historyHandled </span><span class="cov8" title="1">{
                                m.textarea, cmd = m.textarea.Update(msg)
                        }</span>
                        <span class="cov8" title="1">cmds = append(cmds, cmd)

                        // After textarea processes key, check if it was Enter (for submission)
                        if msg.String() == "enter" </span><span class="cov0" title="0">{
                                input := strings.TrimSpace(m.textarea.Value())
                                if input != "" </span><span class="cov0" title="0">{
                                        // Add to history via input manager
                                        if m.inputManager != nil </span><span class="cov0" title="0">{
                                                m.inputManager.AddToHistory(input)
                                        }</span>

                                        <span class="cov0" title="0">if strings.HasPrefix(input, "/") </span><span class="cov0" title="0">{
                                                // Handle chat commands
                                                cmd := m.handleCommand(input)
                                                m.textarea.Reset()
                                                if m.inputManager != nil </span><span class="cov0" title="0">{
                                                        m.inputManager.ClearCompletions()
                                                }</span>
                                                <span class="cov0" title="0">return m, cmd</span>
                                        } else<span class="cov0" title="0"> {
                                                // Add user message
                                                m.addMessage("user", input)

                                                // Send to API
                                                if m.apiClient != nil </span><span class="cov0" title="0">{
                                                        contextPrompt := ""
                                                        if len(m.fileContext.Files) &gt; 0 </span><span class="cov0" title="0">{
                                                                contextPrompt = m.fileContext.BuildContextPrompt()
                                                        }</span>

                                                        <span class="cov0" title="0">m.textarea.Reset()
                                                        if m.inputManager != nil </span><span class="cov0" title="0">{
                                                                m.inputManager.ClearCompletions()
                                                        }</span>
                                                        <span class="cov0" title="0">m.isLoading = true
                                                        m.loadingMsg = "Thinking..."
                                                        m.refreshViewport()

                                                        return m, m.callAPI(contextPrompt, input)</span>
                                                } else<span class="cov0" title="0"> {
                                                        m.addMessage("system", "Please set DEEPSEEK_API_KEY environment variable")
                                                        m.textarea.Reset()
                                                }</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
                }
        }
        // End of switch statement handling

        // If we have an error type message, handle it
        <span class="cov0" title="0">if err, ok := msg.(error); ok </span><span class="cov0" title="0">{
                m.addMessage("system", fmt.Sprintf("‚ùå Unexpected error: %v", err))
        }</span>

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

func (m NewModel) View() string <span class="cov0" title="0">{
        if !m.ready </span><span class="cov0" title="0">{
                return "\n  Initializing..."
        }</span>

        // Build header using layout manager
        <span class="cov0" title="0">filesCount := len(m.fileContext.Files)
        header := m.layoutManager.RenderHeader(filesCount, m.focusMode)

        // Build main content area using layout manager
        chatContent := m.viewport.View()
        sidebarContent := m.sidebarViewport.View()
        mainContent := m.layoutManager.RenderMainContent(chatContent, sidebarContent, m.width, m.filesWidgetVisible, m.focusMode)

        // Build footer using layout manager
        inputArea := m.textarea.View()
        completions := []string{}
        completionIndex := 0
        if m.inputManager != nil </span><span class="cov0" title="0">{
                completions, completionIndex, _ = m.inputManager.GetCompletionState()
        }</span>
        <span class="cov0" title="0">footer := m.layoutManager.RenderFooter(inputArea, completions, completionIndex, m.width)

        // Combine all parts: header + main content + footer
        // This ensures header stays fixed at top while viewport scrolls
        return fmt.Sprintf("%s\n%s\n%s", header, mainContent, footer)</span>
}

// renderFilesSidebar creates the files sidebar content
func (m *NewModel) renderFilesSidebar() string <span class="cov0" title="0">{
        return m.sidebar.RenderFilesSidebar(m.fileContext)
}</span>


// layout calculates and sets proper dimensions for all components
func (m *NewModel) layout() <span class="cov0" title="0">{
        // Calculate viewport dimensions using layout manager
        hasCompletions := false
        if m.inputManager != nil </span><span class="cov0" title="0">{
                completions, _, showCompletions := m.inputManager.GetCompletionState()
                hasCompletions = showCompletions &amp;&amp; len(completions) &gt; 0
        }</span>
        <span class="cov0" title="0">viewportHeight, yPosition := m.layoutManager.CalculateViewportDimensions(m.height, hasCompletions)

        // Update viewports with proper Y position
        m.viewport.Height = viewportHeight
        m.viewport.YPosition = yPosition  // Start after header

        m.sidebarViewport.Height = viewportHeight
        m.sidebarViewport.YPosition = yPosition  // Start after header

        // Update textarea width using layout manager
        textareaWidth := m.layoutManager.CalculateTextareaWidth(m.width, m.filesWidgetVisible)
        m.textarea.SetWidth(textareaWidth)</span>
}

func (m *NewModel) addMessage(role, content string) <span class="cov0" title="0">{
        // Update renderer with current viewport dimensions
        if m.renderer != nil </span><span class="cov0" title="0">{
                m.renderer.SetViewportWidth(m.viewport.Width, m.filesWidgetVisible)
        }</span>

        // Save to session database
        <span class="cov0" title="0">if m.sessionManager != nil &amp;&amp; m.currentSession != nil &amp;&amp; role != "system" </span><span class="cov0" title="0">{
                m.sessionManager.SaveMessage(m.currentSession.ID, role, content)
        }</span>

        // Store in API format for conversation context (exclude system messages)
        <span class="cov0" title="0">if role != "system" </span><span class="cov0" title="0">{
                m.apiMessages = append(m.apiMessages, api.Message{
                        Role:    role,
                        Content: content,
                })
                // Sync with AI operations
                if m.aiOperations != nil </span><span class="cov0" title="0">{
                        m.aiOperations.SetAPIMessages(m.apiMessages)
                }</span>
        }

        // Use renderer to format the message
        <span class="cov0" title="0">var formattedContent string
        if m.renderer != nil </span><span class="cov0" title="0">{
                formattedContent = m.renderer.FormatMessage(role, content)
        }</span> else<span class="cov0" title="0"> {
                // Fallback if renderer is not available
                formattedContent = fmt.Sprintf("%s: %s", role, content)
        }</span>
        
        // Add to message history
        <span class="cov0" title="0">m.messages = append(m.messages, formattedContent)
        
        // Rebuild full content from all messages
        fullContent := strings.Join(m.messages, "\n\n")
        m.viewport.SetContent(fullContent)
        m.viewport.GotoBottom()</span>
}

func (m *NewModel) refreshViewport() <span class="cov0" title="0">{
        // Rebuild viewport from message history
        if m.isLoading </span><span class="cov0" title="0">{
                // Add loading indicator temporarily
                loadingStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("220")).Bold(true)
                loadingMsg := loadingStyle.Render("üîÑ " + m.loadingMsg)

                // Add hint about cancellation
                hintStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("244"))
                hintMsg := hintStyle.Render("Press Esc to cancel")

                // Show all messages plus loading indicator
                allContent := strings.Join(m.messages, "\n\n")
                if allContent != "" </span><span class="cov0" title="0">{
                        m.viewport.SetContent(allContent + "\n\n" + loadingMsg + "\n" + hintMsg)
                }</span> else<span class="cov0" title="0"> {
                        m.viewport.SetContent(loadingMsg + "\n" + hintMsg)
                }</span>
                <span class="cov0" title="0">m.viewport.GotoBottom()</span>
        } else<span class="cov0" title="0"> {
                // Just show all messages
                fullContent := strings.Join(m.messages, "\n\n")
                m.viewport.SetContent(fullContent)
        }</span>
}


// Command handling and async functions (keeping the same logic)
func (m *NewModel) handleCommand(input string) tea.Cmd <span class="cov0" title="0">{
        // Update command handler with fresh dependencies before handling
        m.commandHandler = commands.NewHandler(m.createCommandDependencies())
        return m.commandHandler.Handle(input)
}</span>




func (m *NewModel) callAPI(contextPrompt, userInput string) tea.Cmd <span class="cov0" title="0">{
        if m.aiOperations == nil </span><span class="cov0" title="0">{
                return func() tea.Msg </span><span class="cov0" title="0">{
                        return ai.APIResponseMsg{Err: fmt.Errorf("AI operations not available")}
                }</span>
        }

        // Use streaming if enabled
        <span class="cov0" title="0">if m.streamingEnabled </span><span class="cov0" title="0">{
                cmd := m.aiOperations.CallAPIStream(contextPrompt, userInput)
                // Store the cancel function
                m.apiCancel = m.aiOperations.GetAPICancel()
                return cmd
        }</span>

        // Fall back to non-streaming
        <span class="cov0" title="0">cmd := m.aiOperations.CallAPI(contextPrompt, userInput)
        // Store the cancel function
        m.apiCancel = m.aiOperations.GetAPICancel()
        return cmd</span>
}

func (m *NewModel) analyzeFiles() tea.Cmd <span class="cov0" title="0">{
        if m.aiOperations == nil </span><span class="cov0" title="0">{
                return func() tea.Msg </span><span class="cov0" title="0">{
                        return ai.APIResponseMsg{Err: fmt.Errorf("AI operations not available")}
                }</span>
        }
        <span class="cov0" title="0">return m.aiOperations.AnalyzeFiles()</span>
}

func (m *NewModel) explainFiles() tea.Cmd <span class="cov0" title="0">{
        if m.aiOperations == nil </span><span class="cov0" title="0">{
                return func() tea.Msg </span><span class="cov0" title="0">{
                        return ai.APIResponseMsg{Err: fmt.Errorf("AI operations not available")}
                }</span>
        }
        <span class="cov0" title="0">return m.aiOperations.ExplainFiles()</span>
}

func (m *NewModel) improveFiles() tea.Cmd <span class="cov0" title="0">{
        if m.aiOperations == nil </span><span class="cov0" title="0">{
                return func() tea.Msg </span><span class="cov0" title="0">{
                        return ai.APIResponseMsg{Err: fmt.Errorf("AI operations not available")}
                }</span>
        }
        <span class="cov0" title="0">return m.aiOperations.ImproveFiles()</span>
}

func (m *NewModel) generateEditSuggestions() tea.Cmd <span class="cov0" title="0">{
        if m.aiOperations == nil </span><span class="cov0" title="0">{
                return func() tea.Msg </span><span class="cov0" title="0">{
                        return ai.APIResponseMsg{Err: fmt.Errorf("AI operations not available")}
                }</span>
        }
        <span class="cov0" title="0">cmd := m.aiOperations.GenerateEditSuggestions()
        // Store the cancel function
        m.apiCancel = m.aiOperations.GetAPICancel()
        return cmd</span>
}








// handleAPIResponse handles API responses for both old and new message types
func (m *NewModel) handleAPIResponse(response string, err error) <span class="cov0" title="0">{
        m.isLoading = false
        m.loadingMsg = ""
        m.apiCancel = nil
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's an enhanced APIError
                if apiErr, ok := err.(api.APIError); ok </span><span class="cov0" title="0">{
                        // Show user-friendly message, but don't show cancellation as error
                        if apiErr.Message != "request cancelled by user" </span><span class="cov0" title="0">{
                                errorMsg := fmt.Sprintf("‚ùå %s", apiErr.UserMessage)
                                if apiErr.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                                        errorMsg += fmt.Sprintf(" (HTTP %d)", apiErr.StatusCode)
                                }</span>
                                <span class="cov0" title="0">m.addMessage("system", errorMsg)</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Fallback to generic error message
                        m.addMessage("system", fmt.Sprintf("‚ùå Error: %v", err))
                }</span>
        } else<span class="cov0" title="0"> {
                m.addMessage("assistant", response)
                // Track files mentioned in the AI response
                if m.fileTracker != nil </span><span class="cov0" title="0">{
                        m.fileTracker.ExtractFilesFromResponseWithContext(response, m.fileContext.Files)
                }</span>
        }
        <span class="cov0" title="0">m.viewport.GotoBottom()</span>
}

// updateStreamingDisplay updates the display with streaming content
// Following the official Bubbletea chat example pattern
func (m *NewModel) updateStreamingDisplay(content string) <span class="cov0" title="0">{
        // Only update if we're in loading/streaming mode and have messages
        if !m.isLoading || len(m.messages) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Update the last message (which should be our streaming assistant message)
        // This follows the exact pattern from the official Bubbletea chat example
        <span class="cov0" title="0">lastIdx := len(m.messages) - 1
        m.messages[lastIdx] = m.renderer.FormatMessage("assistant", content)

        // Follow official pattern: SetContent + GotoBottom
        m.viewport.SetContent(strings.Join(m.messages, "\n\n"))
        m.viewport.GotoBottom()</span>
}

// handleStreamComplete handles the completion of a stream
func (m *NewModel) handleStreamComplete(content string, err error) <span class="cov0" title="0">{
        m.isLoading = false
        m.loadingMsg = ""
        m.apiCancel = nil
        m.streamReader = nil
        m.streamContent = ""

        if err != nil </span><span class="cov0" title="0">{
                // Check if it's an enhanced APIError
                if apiErr, ok := err.(api.APIError); ok </span><span class="cov0" title="0">{
                        // Show user-friendly message, but don't show cancellation as error
                        if apiErr.Message != "request cancelled by user" </span><span class="cov0" title="0">{
                                errorMsg := fmt.Sprintf("‚ùå %s", apiErr.UserMessage)
                                if apiErr.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                                        errorMsg += fmt.Sprintf(" (HTTP %d)", apiErr.StatusCode)
                                }</span>
                                <span class="cov0" title="0">m.addMessage("system", errorMsg)</span>
                        }
                } else<span class="cov0" title="0"> if err != context.Canceled </span><span class="cov0" title="0">{
                        // Don't show error for context cancellation
                        m.addMessage("system", fmt.Sprintf("‚ùå Error: %v", err))
                }</span>
        } else<span class="cov0" title="0"> {
                // Ensure final content is properly set (update the last message with final content)
                if len(m.messages) &gt; 0 </span><span class="cov0" title="0">{
                        lastIdx := len(m.messages) - 1
                        m.messages[lastIdx] = m.renderer.FormatMessage("assistant", content)
                        m.viewport.SetContent(strings.Join(m.messages, "\n\n"))
                }</span>

                // Track files mentioned in the AI response
                <span class="cov0" title="0">if m.fileTracker != nil </span><span class="cov0" title="0">{
                        m.fileTracker.ExtractFilesFromResponseWithContext(content, m.fileContext.Files)
                }</span>
                // Add to API messages for history
                <span class="cov0" title="0">m.apiMessages = append(m.apiMessages, api.Message{
                        Role:    "assistant",
                        Content: content,
                })</span>
        }
        <span class="cov0" title="0">m.viewport.GotoBottom()</span>
}

func (m *NewModel) loadPreviousSession() error <span class="cov0" title="0">{
        if m.sessionLoader == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no session loader available")
        }</span>

        <span class="cov0" title="0">messages, apiMessages, err := m.sessionLoader.LoadSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.messages = messages
        m.apiMessages = apiMessages
        // Sync with AI operations
        if m.aiOperations != nil </span><span class="cov0" title="0">{
                m.aiOperations.SetAPIMessages(m.apiMessages)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tracker

import (
        "path/filepath"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/antenore/deecli/internal/files"
)

// TrackedFile represents a file mentioned in an AI response
type TrackedFile struct {
        Path        string
        Description string
        Timestamp   time.Time
        Source      string // "ai_response", "user_mention", "edit_suggestion"
}

// FileTracker tracks files mentioned in AI responses
type FileTracker struct {
        mu    sync.RWMutex
        files []TrackedFile
}

// NewFileTracker creates a new file tracker
func NewFileTracker() *FileTracker <span class="cov8" title="1">{
        return &amp;FileTracker{
                files: make([]TrackedFile, 0),
        }
}</span>

// ExtractFilesFromResponse extracts file paths from an AI response
func (ft *FileTracker) ExtractFilesFromResponse(response string) []TrackedFile <span class="cov8" title="1">{
        return ft.ExtractFilesFromResponseWithContext(response, nil)
}</span>

// ExtractFilesFromResponseWithContext extracts file paths from an AI response
// and resolves full paths using loaded files context if provided
func (ft *FileTracker) ExtractFilesFromResponseWithContext(response string, loadedFiles []files.LoadedFile) []TrackedFile <span class="cov8" title="1">{
        ft.mu.Lock()
        defer ft.mu.Unlock()

        var extracted []TrackedFile

        // Check if this response contains edit suggestions based on keywords
        isEditSuggestionResponse := strings.Contains(response, "Edit Suggestions") ||
                strings.Contains(response, "edit suggestions") ||
                strings.Contains(response, "üìù") ||
                strings.Contains(response, "suggested improvements") ||
                strings.Contains(response, "improvements")

        // Pattern 1: Markdown code blocks with file paths
        // Example: ```go:path/to/file.go
        codeBlockPattern := regexp.MustCompile(`(?m)^\x60{3}[\w]*:([^\s\x60]+)`)
        matches := codeBlockPattern.FindAllStringSubmatch(response, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        source := "ai_response"
                        if isEditSuggestionResponse </span><span class="cov0" title="0">{
                                source = "edit_suggestion"
                        }</span>
                        <span class="cov8" title="1">cleanedPath := cleanPath(match[1])
                        resolvedPath := resolvePathFromLoadedFiles(cleanedPath, loadedFiles)
                        file := TrackedFile{
                                Path:        resolvedPath,
                                Description: "Code block reference",
                                Timestamp:   time.Now(),
                                Source:      source,
                        }
                        extracted = append(extracted, file)</span>
                }
        }

        // Pattern 2: Bullet point file suggestions (for /edit suggestions) - check first
        // Example: "‚Ä¢ **filename.ext** - Description"
        <span class="cov8" title="1">bulletPattern := regexp.MustCompile(`(?m)^[‚Ä¢\-*]\s*\*{0,2}([a-zA-Z0-9_\-/]+\.[a-zA-Z0-9]+)\*{0,2}\s*[-‚Äì]\s*(.+)$`)
        bulletMatches := bulletPattern.FindAllStringSubmatch(response, -1)
        for _, match := range bulletMatches </span><span class="cov8" title="1">{
                if len(match) &gt; 2 </span><span class="cov8" title="1">{
                        cleanedPath := cleanPath(match[1])
                        resolvedPath := resolvePathFromLoadedFiles(cleanedPath, loadedFiles)
                        file := TrackedFile{
                                Path:        resolvedPath,
                                Description: strings.TrimSpace(match[2]),
                                Timestamp:   time.Now(),
                                Source:      "edit_suggestion",
                        }
                        if !containsFile(extracted, file.Path) </span><span class="cov8" title="1">{
                                extracted = append(extracted, file)
                        }</span>
                }
        }

        // Pattern 3: Explicit file mentions with extensions
        // Example: "Edit the file main.go" or "in src/utils/helper.js"
        // Only mark as edit_suggestion if the response seems to be giving suggestions
        <span class="cov8" title="1">filePattern := regexp.MustCompile(`\b([a-zA-Z0-9_\-/]+\.[a-zA-Z0-9]+)\b`)
        matches = filePattern.FindAllStringSubmatch(response, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 &amp;&amp; isValidFilePath(match[1]) </span><span class="cov8" title="1">{
                        source := "ai_response"
                        description := "File mention"

                        // If this looks like an edit suggestion response, mark files as suggestions
                        if isEditSuggestionResponse </span><span class="cov8" title="1">{
                                source = "edit_suggestion"
                                description = "Suggested file"
                        }</span>

                        <span class="cov8" title="1">cleanedPath := cleanPath(match[1])
                        resolvedPath := resolvePathFromLoadedFiles(cleanedPath, loadedFiles)
                        file := TrackedFile{
                                Path:        resolvedPath,
                                Description: description,
                                Timestamp:   time.Now(),
                                Source:      source,
                        }
                        // Don't add if already extracted from bullet points
                        if !containsFile(extracted, file.Path) </span><span class="cov8" title="1">{
                                extracted = append(extracted, file)
                        }</span>
                }
        }

        // Add extracted files to the tracker
        <span class="cov8" title="1">ft.files = append(ft.files, extracted...)

        // Keep only the most recent 50 files
        if len(ft.files) &gt; 50 </span><span class="cov8" title="1">{
                ft.files = ft.files[len(ft.files)-50:]
        }</span>

        <span class="cov8" title="1">return extracted</span>
}

// GetRecentFiles returns the most recent tracked files
func (ft *FileTracker) GetRecentFiles(limit int) []TrackedFile <span class="cov8" title="1">{
        ft.mu.RLock()
        defer ft.mu.RUnlock()

        if limit &lt;= 0 || limit &gt; len(ft.files) </span><span class="cov8" title="1">{
                limit = len(ft.files)
        }</span>

        // Return files in reverse order (most recent first)
        <span class="cov8" title="1">result := make([]TrackedFile, limit)
        for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                result[i] = ft.files[len(ft.files)-1-i]
        }</span>

        <span class="cov8" title="1">return result</span>
}

// GetEditSuggestions returns files marked as edit suggestions
func (ft *FileTracker) GetEditSuggestions() []TrackedFile <span class="cov8" title="1">{
        ft.mu.RLock()
        defer ft.mu.RUnlock()

        var suggestions []TrackedFile
        for i := len(ft.files) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if ft.files[i].Source == "edit_suggestion" </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, ft.files[i])
                }</span>
        }

        <span class="cov8" title="1">return suggestions</span>
}

// Clear removes all tracked files
func (ft *FileTracker) Clear() <span class="cov8" title="1">{
        ft.mu.Lock()
        defer ft.mu.Unlock()
        ft.files = make([]TrackedFile, 0)
}</span>

// HasSuggestions returns true if there are any edit suggestions
func (ft *FileTracker) HasSuggestions() bool <span class="cov8" title="1">{
        ft.mu.RLock()
        defer ft.mu.RUnlock()

        for _, file := range ft.files </span><span class="cov8" title="1">{
                if file.Source == "edit_suggestion" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Helper functions

func cleanPath(path string) string <span class="cov8" title="1">{
        // Remove leading/trailing whitespace and quotes
        path = strings.TrimSpace(path)
        path = strings.Trim(path, `"'`)

        // Clean the path
        return filepath.Clean(path)
}</span>

func isValidFilePath(path string) bool <span class="cov8" title="1">{
        // Check if it has a valid extension
        ext := filepath.Ext(path)
        if ext == "" || len(ext) &gt; 10 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for common programming file extensions
        <span class="cov8" title="1">validExtensions := []string{
                ".go", ".js", ".ts", ".jsx", ".tsx", ".py", ".rb", ".java", ".c", ".cpp",
                ".h", ".hpp", ".cs", ".php", ".swift", ".kt", ".rs", ".vue", ".html",
                ".css", ".scss", ".sass", ".json", ".xml", ".yaml", ".yml", ".toml",
                ".md", ".txt", ".sh", ".bash", ".sql", ".lua", ".vim", ".el",
        }

        for _, validExt := range validExtensions </span><span class="cov8" title="1">{
                if strings.EqualFold(ext, validExt) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func containsFile(files []TrackedFile, path string) bool <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                if file.Path == path </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// resolvePathFromLoadedFiles attempts to find the full path for a filename
// by checking against loaded files in the context
func resolvePathFromLoadedFiles(path string, loadedFiles []files.LoadedFile) string <span class="cov8" title="1">{
        if loadedFiles == nil || len(loadedFiles) == 0 </span><span class="cov8" title="1">{
                return path
        }</span>

        // Clean the path first
        <span class="cov0" title="0">cleanedPath := strings.TrimSpace(path)

        // First check for exact match
        for _, loaded := range loadedFiles </span><span class="cov0" title="0">{
                if loaded.RelPath == cleanedPath || loaded.Path == cleanedPath </span><span class="cov0" title="0">{
                        return loaded.RelPath
                }</span>
        }

        // Check if the path is just a filename and match against loaded files
        <span class="cov0" title="0">baseName := filepath.Base(cleanedPath)
        for _, loaded := range loadedFiles </span><span class="cov0" title="0">{
                loadedBaseName := filepath.Base(loaded.RelPath)
                if loadedBaseName == baseName </span><span class="cov0" title="0">{
                        // Found a match - use the full relative path from the loaded file
                        return loaded.RelPath
                }</span>
        }

        // No match found, return original path
        <span class="cov0" title="0">return cleanedPath</span>
}</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ui

import (
        "fmt"
        "strings"

        "github.com/antenore/deecli/internal/config"
        "github.com/charmbracelet/lipgloss"
)

// Layout handles terminal layout calculations and header rendering
type Layout struct {
        configManager *config.Manager
}

// NewLayout creates a new layout manager
func NewLayout(configManager *config.Manager) *Layout <span class="cov0" title="0">{
        return &amp;Layout{configManager: configManager}
}</span>

// CalculateViewportDimensions calculates viewport height and positioning
func (l *Layout) CalculateViewportDimensions(terminalHeight int, showCompletions bool) (height, yPosition int) <span class="cov0" title="0">{
        // Calculate available space
        headerHeight := 1    // Header line
        separatorHeight := 1 // Separator line
        inputHeight := 3     // Textarea height
        completionHeight := 0

        if showCompletions </span><span class="cov0" title="0">{
                completionHeight = 1
        }</span>

        // Calculate viewport height - subtract an extra 1 for safety
        <span class="cov0" title="0">viewportHeight := terminalHeight - headerHeight - separatorHeight - inputHeight - completionHeight - 1
        if viewportHeight &lt; 3 </span><span class="cov0" title="0">{
                viewportHeight = 3
        }</span>

        <span class="cov0" title="0">return viewportHeight, headerHeight</span>
}

// CalculateTextareaWidth calculates textarea width based on layout
func (l *Layout) CalculateTextareaWidth(terminalWidth int, sidebarVisible bool) int <span class="cov0" title="0">{
        textareaWidth := terminalWidth - 4
        if sidebarVisible </span><span class="cov0" title="0">{
                textareaWidth = terminalWidth - 30 // Account for sidebar
        }</span>
        <span class="cov0" title="0">if textareaWidth &lt; 20 </span><span class="cov0" title="0">{
                textareaWidth = 20 // Minimum width
        }</span>
        <span class="cov0" title="0">return textareaWidth</span>
}

// RenderHeader creates the application header
func (l *Layout) RenderHeader(filesCount int, focusMode string) string <span class="cov0" title="0">{
        headerStyle := lipgloss.NewStyle().
                Background(lipgloss.Color("62")).
                Foreground(lipgloss.Color("230")).
                Padding(0, 1)

        focusIndicator := ""
        switch focusMode </span>{
        case "viewport":<span class="cov0" title="0">
                focusIndicator = " | üìú CHAT"</span>
        case "sidebar":<span class="cov0" title="0">
                focusIndicator = " | üìÅ FILES"</span>
        default:<span class="cov0" title="0">
                focusIndicator = " | ‚úèÔ∏è INPUT"</span>
        }

        // Get newline key display
        <span class="cov0" title="0">newlineKeyDisplay := "Ctrl+J" // Default
        if l.configManager != nil </span><span class="cov0" title="0">{
                key := l.configManager.GetNewlineKey()
                // Format key for display (e.g., "ctrl+j" -&gt; "Ctrl+J")
                newlineKeyDisplay = l.FormatKeyForDisplay(key)
        }</span>

        <span class="cov0" title="0">header := headerStyle.Render(fmt.Sprintf("DeeCLI | F: %d | NL: %s | F1 | F2 | Tab%s",
                filesCount, newlineKeyDisplay, focusIndicator))

        return header</span>
}

// RenderMainContent creates the main content area with optional sidebar
func (l *Layout) RenderMainContent(chatContent, sidebarContent string, terminalWidth int, sidebarVisible bool, focusMode string) string <span class="cov0" title="0">{
        if !sidebarVisible </span><span class="cov0" title="0">{
                // Single column: just the viewport
                return chatContent
        }</span>

        // Two-column layout: chat viewport + files sidebar
        <span class="cov0" title="0">sidebarWidth := 25
        chatWidth := terminalWidth - sidebarWidth - 3 // -3 for " ‚îÇ " separator
        if chatWidth &lt; 40 </span><span class="cov0" title="0">{
                chatWidth = 40
        }</span>

        // Create styles with focus indicators
        <span class="cov0" title="0">chatBorderColor := lipgloss.Color("244")
        sidebarBorderColor := lipgloss.Color("244")

        if focusMode == "viewport" </span><span class="cov0" title="0">{
                chatBorderColor = lipgloss.Color("220") // Yellow for focused
        }</span> else<span class="cov0" title="0"> if focusMode == "sidebar" </span><span class="cov0" title="0">{
                sidebarBorderColor = lipgloss.Color("220") // Yellow for focused
        }</span>

        <span class="cov0" title="0">chatStyle := lipgloss.NewStyle().
                Width(chatWidth).
                MaxWidth(chatWidth).
                BorderStyle(lipgloss.RoundedBorder()).
                BorderRight(true).
                BorderForeground(chatBorderColor)

        sidebarStyle := lipgloss.NewStyle().
                Width(sidebarWidth).
                MaxWidth(sidebarWidth).
                BorderStyle(lipgloss.RoundedBorder()).
                BorderLeft(true).
                BorderForeground(sidebarBorderColor)

        // Render both columns with proper width constraints
        chatColumn := chatStyle.Render(chatContent)
        sidebarColumn := sidebarStyle.Render(sidebarContent)

        // Use lipgloss to join them horizontally
        return lipgloss.JoinHorizontal(
                lipgloss.Top,
                chatColumn,
                sidebarColumn,
        )</span>
}

// RenderFooter creates the footer with input area and completions
func (l *Layout) RenderFooter(inputContent string, completions []string, completionIndex int, terminalWidth int) string <span class="cov0" title="0">{
        var footerContent strings.Builder

        // Separator
        separator := strings.Repeat("‚îÄ", terminalWidth)
        footerContent.WriteString(separator + "\n")

        // Input area
        footerContent.WriteString(inputContent)

        // Add completions if visible
        if len(completions) &gt; 0 </span><span class="cov0" title="0">{
                completionStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("244")).
                        Background(lipgloss.Color("235")).
                        Padding(0, 1)

                completionList := fmt.Sprintf("Completions (%d/%d): ", completionIndex+1, len(completions))
                for i, comp := range completions </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                completionList += "  "
                        }</span>
                        <span class="cov0" title="0">if i &gt;= 10 </span><span class="cov0" title="0">{
                                completionList += fmt.Sprintf("... +%d more", len(completions)-10)
                                break</span>
                        }

                        // Highlight the currently selected completion
                        <span class="cov0" title="0">if i == completionIndex </span><span class="cov0" title="0">{
                                highlightStyle := lipgloss.NewStyle().
                                        Foreground(lipgloss.Color("220")).
                                        Background(lipgloss.Color("235")).
                                        Bold(true)
                                completionList += highlightStyle.Render(comp)
                        }</span> else<span class="cov0" title="0"> {
                                completionList += comp
                        }</span>
                }
                <span class="cov0" title="0">footerContent.WriteString("\n" + completionStyle.Render(completionList))</span>
        }

        <span class="cov0" title="0">return footerContent.String()</span>
}

// FormatKeyForDisplay formats a key string for user-friendly display
func (l *Layout) FormatKeyForDisplay(key string) string <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return "Ctrl+J" // Default
        }</span>

        // Split by + and capitalize each part
        <span class="cov0" title="0">parts := strings.Split(key, "+")
        for i, part := range parts </span><span class="cov0" title="0">{
                switch strings.ToLower(part) </span>{
                case "ctrl":<span class="cov0" title="0">
                        parts[i] = "Ctrl"</span>
                case "alt":<span class="cov0" title="0">
                        parts[i] = "Alt"</span>
                case "shift":<span class="cov0" title="0">
                        parts[i] = "Shift"</span>
                case "enter":<span class="cov0" title="0">
                        parts[i] = "Enter"</span>
                default:<span class="cov0" title="0">
                        // Uppercase single letters (j -&gt; J, m -&gt; M)
                        if len(part) == 1 </span><span class="cov0" title="0">{
                                parts[i] = strings.ToUpper(part)
                        }</span> else<span class="cov0" title="0"> {
                                // Capitalize first letter of words
                                parts[i] = strings.Title(part)
                        }</span>
                }
        }
        <span class="cov0" title="0">return strings.Join(parts, "+")</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ui

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/antenore/deecli/internal/config"
        "github.com/charmbracelet/lipgloss"
)

// Renderer handles message formatting and display content
type Renderer struct {
        configManager *config.Manager
        viewportWidth int
        sidebarVisible bool
}

// NewRenderer creates a new renderer
func NewRenderer(configManager *config.Manager) *Renderer <span class="cov0" title="0">{
        return &amp;Renderer{
                configManager: configManager,
        }
}</span>

// SetViewportWidth updates the viewport width for text wrapping
func (r *Renderer) SetViewportWidth(width int, sidebarVisible bool) <span class="cov0" title="0">{
        r.viewportWidth = width
        r.sidebarVisible = sidebarVisible
}</span>

// FormatMessage formats a message with proper styling and wrapping
func (r *Renderer) FormatMessage(role, content string) string <span class="cov0" title="0">{
        var style lipgloss.Style
        var prefix string

        switch role </span>{
        case "user":<span class="cov0" title="0">
                style = lipgloss.NewStyle().Foreground(lipgloss.Color("220")).Bold(true)
                prefix = "You: "</span>
        case "assistant":<span class="cov0" title="0">
                style = lipgloss.NewStyle().Foreground(lipgloss.Color("86")).Bold(true)
                prefix = "DeeCLI: "</span>
        case "system":<span class="cov0" title="0">
                style = lipgloss.NewStyle().Foreground(lipgloss.Color("244"))
                prefix = "System: "</span>
        }

        // Calculate available width for content
        <span class="cov0" title="0">availableWidth := r.viewportWidth - len(prefix) - 2 // Account for prefix and some padding
        if r.sidebarVisible </span><span class="cov0" title="0">{
                // Adjust for sidebar taking up space
                availableWidth = r.viewportWidth - 30 // Account for sidebar width
        }</span>
        <span class="cov0" title="0">if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20 // Minimum readable width
        }</span>

        // Use lipgloss to wrap text
        <span class="cov0" title="0">wrapper := lipgloss.NewStyle().Width(availableWidth)
        wrappedContent := wrapper.Render(content)

        return style.Render(prefix) + wrappedContent</span>
}

// FormatInitialContent creates the welcome message
func (r *Renderer) FormatInitialContent() string <span class="cov0" title="0">{
        // Get current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                cwd = "unknown"
        }</span>

        // Get current key bindings for display
        <span class="cov0" title="0">newlineKey := "Ctrl+J"
        historyBackKey := "Ctrl+P"
        historyForwardKey := "Ctrl+N"
        if r.configManager != nil </span><span class="cov0" title="0">{
                newlineKey = r.formatKeyForDisplay(r.configManager.GetNewlineKey())
                historyBackKey = r.formatKeyForDisplay(r.configManager.GetHistoryBackKey())
                historyForwardKey = r.formatKeyForDisplay(r.configManager.GetHistoryForwardKey())
        }</span>

        // Compact welcome screen
        <span class="cov0" title="0">welcomeContent := fmt.Sprintf(`üêâ DeeCLI - AI Code Assistant | %s

Essential Commands: /load &lt;file&gt; /add &lt;file&gt; /list /clear /analyze /config /history /help
Quick Keys: Tab=complete/focus %s=newline ‚Üë/‚Üì or %s/%s=history F1=help F2=files

üí° Start by loading files: /load *.go or /load main.go
   Press F1 for detailed help, Tab for completion`,
                filepath.Base(cwd), newlineKey, historyBackKey, historyForwardKey)

        return welcomeContent</span>
}

// FormatHelpContent creates the detailed help content
func (r *Renderer) FormatHelpContent() string <span class="cov0" title="0">{
        // Get current key bindings
        newlineKey := "Ctrl+J"
        historyBackKey := "Ctrl+P"
        historyForwardKey := "Ctrl+N"

        if r.configManager != nil </span><span class="cov0" title="0">{
                newlineKey = r.formatKeyForDisplay(r.configManager.GetNewlineKey())
                historyBackKey = r.formatKeyForDisplay(r.configManager.GetHistoryBackKey())
                historyForwardKey = r.formatKeyForDisplay(r.configManager.GetHistoryForwardKey())
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`üêâ DeeCLI Help

=== Multi-line Input ===
‚Ä¢ Enter: Send message
‚Ä¢ %s: New line in message
‚Ä¢ Type naturally across multiple lines

=== History Navigation ===
‚Ä¢ %s: Previous command/message
‚Ä¢ %s: Next command/message

=== Chat Commands ===
/load &lt;file&gt;    Load a file or glob pattern
/add &lt;file&gt;     Add another file to context
/list           List all loaded files
/clear          Clear all loaded files
/analyze        Analyze loaded files
/improve        Get improvement suggestions
/explain        Explain loaded code
/edit           AI suggests which files to edit based on conversation
/edit &lt;file&gt;    Open specific file in editor
/config         View/manage configuration settings
/keysetup       Configure key bindings
/history        View/manage command history
/help           Show this help
/quit           Exit the application

=== Keyboard Shortcuts ===
Tab             Smart: show/accept completions OR switch focus
Enter           Send message
%s         New line in message
‚Üë or %s    Previous history (single-line input only)
‚Üì or %s    Next history (single-line input only)
F1              Toggle this help
F2              Toggle files sidebar
Esc             Cancel ongoing AI response
Ctrl+C          Exit application
Ctrl+W          Delete word backward
Ctrl+U/K        Delete to line start/end
Alt+Backspace   Delete word backward (alternative)

=== Focus Modes ===
‚úèÔ∏è INPUT        Type messages and commands
üìú CHAT         Scroll through chat history
üìÅ FILES        Browse loaded files (when F2 open)

Tab cycles focus: Input ‚Üí Chat ‚Üí Files (if open) ‚Üí Input

=== Navigation ===
‚Üë/‚Üì             Scroll in viewport/sidebar OR history in input (single-line)
PgUp/PgDn       Page up/down
Ctrl+U/Ctrl+D   Half page up/down
Home/End        Jump to top/bottom
Esc/Enter       Return to input mode

Tip: Yellow border shows which pane has focus!

=== File Patterns ===
You can use glob patterns to load multiple files:
  /load *.go           Load all .go files
  /load src/**/*.go    Load all .go files in src
  /load {*.go,*.md}    Load all .go and .md files

=== Tips ===
‚Ä¢ Multi-line messages: Use %s to add new lines
‚Ä¢ Quick submit: Just press Enter to send your message
‚Ä¢ Press Tab (when no completions) to switch between panes
‚Ä¢ Standard text editing shortcuts work (Ctrl+W, Ctrl+U, Ctrl+K, etc.)
‚Ä¢ Yellow border shows which pane has focus
‚Ä¢ Tab shows completions, use ‚Üë‚Üì arrows to cycle, Tab/Enter to accept, Esc to cancel
‚Ä¢ Arrow keys scroll in focused panes
‚Ä¢ Press Esc to quickly return to input mode

Press F1 to close this help`, newlineKey, historyBackKey, historyForwardKey,
                newlineKey, historyBackKey, historyForwardKey, newlineKey)</span>
}

// FormatLoadingMessage creates a loading message with cancel hint
func (r *Renderer) FormatLoadingMessage(loadingMsg string) string <span class="cov0" title="0">{
        // Add loading indicator
        loadingStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("220")).Bold(true)
        loadingText := loadingStyle.Render("üîÑ " + loadingMsg)

        // Add hint about cancellation
        hintStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("244"))
        hintText := hintStyle.Render("Press Esc to cancel")

        return loadingText + "\n" + hintText
}</span>

// formatKeyForDisplay formats a key string for user-friendly display
func (r *Renderer) formatKeyForDisplay(key string) string <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return "Ctrl+J" // Default
        }</span>

        // Split by + and capitalize each part
        <span class="cov0" title="0">parts := strings.Split(key, "+")
        for i, part := range parts </span><span class="cov0" title="0">{
                switch strings.ToLower(part) </span>{
                case "ctrl":<span class="cov0" title="0">
                        parts[i] = "Ctrl"</span>
                case "alt":<span class="cov0" title="0">
                        parts[i] = "Alt"</span>
                case "shift":<span class="cov0" title="0">
                        parts[i] = "Shift"</span>
                case "enter":<span class="cov0" title="0">
                        parts[i] = "Enter"</span>
                default:<span class="cov0" title="0">
                        // Uppercase single letters (j -&gt; J, m -&gt; M)
                        if len(part) == 1 </span><span class="cov0" title="0">{
                                parts[i] = strings.ToUpper(part)
                        }</span> else<span class="cov0" title="0"> {
                                // Capitalize first letter of words
                                parts[i] = strings.Title(part)
                        }</span>
                }
        }
        <span class="cov0" title="0">return strings.Join(parts, "+")</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ui

import (
        "fmt"
        "strings"

        "github.com/antenore/deecli/internal/files"
        "github.com/charmbracelet/lipgloss"
)

// Sidebar handles the files sidebar rendering
type Sidebar struct{}

// NewSidebar creates a new sidebar
func NewSidebar() *Sidebar <span class="cov0" title="0">{
        return &amp;Sidebar{}
}</span>

// RenderFilesSidebar creates the files sidebar content
func (s *Sidebar) RenderFilesSidebar(fileContext *files.FileContext) string <span class="cov0" title="0">{
        var sb strings.Builder

        // Sidebar title
        titleStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("212")).
                Bold(true)
        sb.WriteString(titleStyle.Render("Files") + "\n")
        sb.WriteString(strings.Repeat("‚îÄ", 22) + "\n")

        if len(fileContext.Files) == 0 </span><span class="cov0" title="0">{
                sb.WriteString(lipgloss.NewStyle().
                        Foreground(lipgloss.Color("244")).
                        Render("No files loaded") + "\n")
                sb.WriteString("\n")
                sb.WriteString(lipgloss.NewStyle().
                        Foreground(lipgloss.Color("244")).
                        Render("Use /load &lt;file&gt;") + "\n")
        }</span> else<span class="cov0" title="0"> {
                // List ALL files with icons and sizes (no limit for scrolling)
                totalSize := int64(0)
                for i, file := range fileContext.Files </span><span class="cov0" title="0">{
                        // Get file type icon
                        icon := s.GetFileTypeIcon(file.Language)

                        // Format file size
                        sizeStr := s.FormatFileSize(file.Size)

                        // File name (truncate if too long for sidebar width)
                        fileName := file.RelPath
                        if len(fileName) &gt; 18 </span><span class="cov0" title="0">{
                                fileName = fileName[:15] + "..."
                        }</span>

                        // File number for future selection
                        <span class="cov0" title="0">numberStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
                        fileStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("252"))

                        // File entry with number
                        sb.WriteString(fmt.Sprintf("%s %s %s\n",
                                numberStyle.Render(fmt.Sprintf("%2d.", i+1)),
                                icon,
                                fileStyle.Render(fileName)))

                        // Size and language (indented)
                        detailStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("244"))
                        sb.WriteString(detailStyle.Render(fmt.Sprintf("     %s ‚Ä¢ %s", file.Language, sizeStr)) + "\n")

                        if i &lt; len(fileContext.Files)-1 </span><span class="cov0" title="0">{
                                sb.WriteString("\n")
                        }</span>

                        <span class="cov0" title="0">totalSize += file.Size</span>
                }

                // Total context size at bottom
                <span class="cov0" title="0">sb.WriteString("\n")
                sb.WriteString(strings.Repeat("‚îÄ", 22) + "\n")
                totalStr := s.FormatFileSize(totalSize)
                sb.WriteString(lipgloss.NewStyle().
                        Foreground(lipgloss.Color("208")).
                        Bold(true).
                        Render(fmt.Sprintf("Total: %s", totalStr)) + "\n")</span>
        }

        <span class="cov0" title="0">return sb.String()</span>
}

// GetFileTypeIcon returns an icon for the given file language
func (s *Sidebar) GetFileTypeIcon(language string) string <span class="cov0" title="0">{
        iconMap := map[string]string{
                "go":         "üêπ",
                "javascript": "üü®",
                "typescript": "üî∑",
                "python":     "üêç",
                "rust":       "ü¶Ä",
                "java":       "‚òï",
                "c":          "‚ö°",
                "cpp":        "‚ö°",
                "html":       "üåê",
                "css":        "üé®",
                "json":       "üìã",
                "yaml":       "üìù",
                "markdown":   "üìñ",
                "sql":        "üóÉÔ∏è",
                "dockerfile": "üê≥",
                "makefile":   "üî®",
                "bash":       "üñ•Ô∏è",
                "text":       "üìÑ",
        }

        if icon, ok := iconMap[language]; ok </span><span class="cov0" title="0">{
                return icon
        }</span>
        <span class="cov0" title="0">return "üìÑ"</span>
}

// FormatFileSize formats bytes into human-readable format
func (s *Sidebar) FormatFileSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%db", bytes)
        }</span>

        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>

        <span class="cov0" title="0">units := []string{"KB", "MB", "GB", "TB"}
        return fmt.Sprintf("%.1f%s", float64(bytes)/float64(div), units[exp])</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package viewport

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/antenore/deecli/internal/api"
        "github.com/antenore/deecli/internal/chat/ui"
        "github.com/antenore/deecli/internal/config"
        "github.com/antenore/deecli/internal/sessions"
        "github.com/charmbracelet/bubbles/viewport"
        "github.com/charmbracelet/lipgloss"
)

// Manager handles viewport and message management
type Manager struct {
        viewport         *viewport.Model
        renderer         *ui.Renderer
        layoutManager    *ui.Layout
        configManager    *config.Manager
        sessionManager   *sessions.Manager
        currentSession   *sessions.Session
        // Use pointers to the actual model data instead of copies
        messages         *[]string
        apiMessages      *[]api.Message
        filesWidgetVisible *bool
        isLoading        *bool
        loadingMsg       *string
}

// Dependencies contains all dependencies needed by the viewport manager
type Dependencies struct {
        Viewport         *viewport.Model
        Renderer         *ui.Renderer
        LayoutManager    *ui.Layout
        ConfigManager    *config.Manager
        SessionManager   *sessions.Manager
        CurrentSession   *sessions.Session
        Messages         *[]string
        APIMessages      *[]api.Message
        FilesWidgetVisible *bool
        IsLoading        *bool
        LoadingMsg       *string
}

// NewManager creates a new viewport manager
func NewManager(deps Dependencies) *Manager <span class="cov0" title="0">{
        return &amp;Manager{
                viewport:         deps.Viewport,
                renderer:         deps.Renderer,
                layoutManager:    deps.LayoutManager,
                configManager:    deps.ConfigManager,
                sessionManager:   deps.SessionManager,
                currentSession:   deps.CurrentSession,
                // Store pointers to actual model data
                messages:         deps.Messages,
                apiMessages:      deps.APIMessages,
                filesWidgetVisible: deps.FilesWidgetVisible,
                isLoading:        deps.IsLoading,
                loadingMsg:       deps.LoadingMsg,
        }
}</span>

// AddMessage adds a message to the viewport
func (m *Manager) AddMessage(role, content string, aiOperations interface{}) <span class="cov0" title="0">{
        // Update renderer with current viewport dimensions
        if m.renderer != nil </span><span class="cov0" title="0">{
                m.renderer.SetViewportWidth(m.viewport.Width, *m.filesWidgetVisible)
        }</span>

        // Save to session database
        <span class="cov0" title="0">if m.sessionManager != nil &amp;&amp; m.currentSession != nil &amp;&amp; role != "system" </span><span class="cov0" title="0">{
                m.sessionManager.SaveMessage(m.currentSession.ID, role, content)
        }</span>

        // Store in API format for conversation context (exclude system messages)
        <span class="cov0" title="0">if role != "system" </span><span class="cov0" title="0">{
                *m.apiMessages = append(*m.apiMessages, api.Message{
                        Role:    role,
                        Content: content,
                })
                // Sync with AI operations (using interface{} to avoid circular imports)
                if aiOps, ok := aiOperations.(interface{ SetAPIMessages([]api.Message) }); ok </span><span class="cov0" title="0">{
                        aiOps.SetAPIMessages(*m.apiMessages)
                }</span>
        }

        // Use renderer to format the message
        <span class="cov0" title="0">var formattedContent string
        if m.renderer != nil </span><span class="cov0" title="0">{
                formattedContent = m.renderer.FormatMessage(role, content)
        }</span> else<span class="cov0" title="0"> {
                // Fallback if renderer is not available
                formattedContent = fmt.Sprintf("%s: %s", role, content)
        }</span>

        // Add to message history
        <span class="cov0" title="0">*m.messages = append(*m.messages, formattedContent)

        // Rebuild full content from all messages
        fullContent := strings.Join(*m.messages, "\n\n")
        m.viewport.SetContent(fullContent)
        m.viewport.GotoBottom()</span>
}

// RefreshViewport refreshes the viewport content
func (m *Manager) RefreshViewport() <span class="cov0" title="0">{
        // Rebuild viewport from message history
        if *m.isLoading </span><span class="cov0" title="0">{
                // Add loading indicator temporarily
                loadingStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("220")).Bold(true)
                loadingMsg := loadingStyle.Render("üîÑ " + *m.loadingMsg)

                // Add hint about cancellation
                hintStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("244"))
                hintMsg := hintStyle.Render("Press Esc to cancel")

                // Show all messages plus loading indicator
                allContent := strings.Join(*m.messages, "\n\n")
                if allContent != "" </span><span class="cov0" title="0">{
                        m.viewport.SetContent(allContent + "\n\n" + loadingMsg + "\n" + hintMsg)
                }</span> else<span class="cov0" title="0"> {
                        m.viewport.SetContent(loadingMsg + "\n" + hintMsg)
                }</span>
                <span class="cov0" title="0">m.viewport.GotoBottom()</span>
        } else<span class="cov0" title="0"> {
                // Just show all messages
                fullContent := strings.Join(*m.messages, "\n\n")
                m.viewport.SetContent(fullContent)
        }</span>
}

// GetTextWidth calculates available text width for messages
func (m *Manager) GetTextWidth() int <span class="cov0" title="0">{
        availableWidth := m.viewport.Width - 10 // Base padding
        if *m.filesWidgetVisible </span><span class="cov0" title="0">{
                // Account for sidebar width and borders
                availableWidth = m.viewport.Width - 35
        }</span>
        <span class="cov0" title="0">if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20 // Minimum readable width
        }</span>
        <span class="cov0" title="0">return availableWidth</span>
}

// FormatInitialContent generates the initial welcome content
func (m *Manager) FormatInitialContent() string <span class="cov0" title="0">{
        // Get current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                cwd = "unknown"
        }</span>
        
        // Get current key bindings for display
        <span class="cov0" title="0">newlineKey := "Ctrl+J"
        historyBackKey := "Ctrl+P"
        historyForwardKey := "Ctrl+N"
        if m.configManager != nil </span><span class="cov0" title="0">{
                newlineKey = m.layoutManager.FormatKeyForDisplay(m.configManager.GetNewlineKey())
                historyBackKey = m.layoutManager.FormatKeyForDisplay(m.configManager.GetHistoryBackKey())
                historyForwardKey = m.layoutManager.FormatKeyForDisplay(m.configManager.GetHistoryForwardKey())
        }</span>

        // Compact welcome screen
        <span class="cov0" title="0">welcomeContent := fmt.Sprintf(`üêâ DeeCLI - AI Code Assistant | %s

Essential Commands: /load &lt;file&gt; /add &lt;file&gt; /list /clear /analyze /history /keysetup /help
Quick Keys: Tab=complete/focus %s=newline ‚Üë/‚Üì or %s/%s=history F1=help F2=files

üí° Start by loading files: /load *.go or /load main.go
   Press F1 for detailed help, Tab for completion`,
                filepath.Base(cwd), newlineKey, historyBackKey, historyForwardKey)
        
        return welcomeContent</span>
}

// HelpContent generates the help content
func (m *Manager) HelpContent() string <span class="cov0" title="0">{
        // Get current key bindings
        newlineKey := "Ctrl+J"
        historyBackKey := "Ctrl+P"
        historyForwardKey := "Ctrl+N"

        if m.configManager != nil </span><span class="cov0" title="0">{
                newlineKey = m.layoutManager.FormatKeyForDisplay(m.configManager.GetNewlineKey())
                historyBackKey = m.layoutManager.FormatKeyForDisplay(m.configManager.GetHistoryBackKey())
                historyForwardKey = m.layoutManager.FormatKeyForDisplay(m.configManager.GetHistoryForwardKey())
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`üêâ DeeCLI Help

=== Multi-line Input ===
‚Ä¢ Enter: Send message
‚Ä¢ %s: New line in message
‚Ä¢ Type naturally across multiple lines

=== History Navigation ===
‚Ä¢ %s: Previous command/message
‚Ä¢ %s: Next command/message

=== Chat Commands ===
/load &lt;file&gt;    Load a file or glob pattern
/add &lt;file&gt;     Add another file to context
/list           List all loaded files
/clear          Clear all loaded files
/analyze        Analyze loaded files
/improve        Get improvement suggestions
/explain        Explain loaded code
/edit           AI suggests which files to edit based on conversation
/edit &lt;file&gt;    Open specific file in editor
/keysetup       Configure key bindings
/history        View/manage command history
/help           Show this help
/quit           Exit the application

=== Keyboard Shortcuts ===
Tab             Smart: show/accept completions OR switch focus
Enter           Send message
%s         New line in message
‚Üë or %s    Previous history (single-line input only)
‚Üì or %s    Next history (single-line input only)
F1              Toggle this help
F2              Toggle files sidebar
Esc             Cancel ongoing AI response
Ctrl+C          Exit application
Ctrl+W          Delete word backward
Ctrl+U/K        Delete to line start/end
Alt+Backspace   Delete word backward (alternative)

=== Focus Modes ===
‚úèÔ∏è INPUT        Type messages and commands
üìú CHAT         Scroll through chat history
üìÅ FILES        Browse loaded files (when F2 open)

Tab cycles focus: Input ‚Üí Chat ‚Üí Files (if open) ‚Üí Input

=== Navigation ===
‚Üë/‚Üì             Scroll in viewport/sidebar OR history in input (single-line)
PgUp/PgDn       Page up/down
Ctrl+U/Ctrl+D   Half page up/down
Home/End        Jump to top/bottom
Esc/Enter       Return to input mode

Tip: Yellow border shows which pane has focus!

=== File Patterns ===
You can use glob patterns to load multiple files:
  /load *.go           Load all .go files
  /load src/**/*.go    Load all .go files in src
  /load {*.go,*.md}    Load all .go and .md files

=== Tips ===
‚Ä¢ Multi-line messages: Use %s to add new lines
‚Ä¢ Quick submit: Just press Enter to send your message
‚Ä¢ Press Tab (when no completions) to switch between panes
‚Ä¢ Standard text editing shortcuts work (Ctrl+W, Ctrl+U, Ctrl+K, etc.)
‚Ä¢ Yellow border shows which pane has focus
‚Ä¢ Tab shows completions, use ‚Üë‚Üì arrows to cycle, Tab/Enter to accept, Esc to cancel
‚Ä¢ Arrow keys scroll in focused panes
‚Ä¢ Press Esc to quickly return to input mode

Press F1 to close this help`, newlineKey, historyBackKey, historyForwardKey,
                newlineKey, historyBackKey, historyForwardKey, newlineKey)</span>
}


// StripANSI removes ANSI color codes from text
func StripANSI(s string) string <span class="cov0" title="0">{
        ansiRegex := regexp.MustCompile(`\x1b\[[0-9;]*[a-zA-Z]`)
        return ansiRegex.ReplaceAllString(s, "")
}</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

type Config struct {
        APIKey      string             `yaml:"api_key"`
        Model       string             `yaml:"model"`
        Temperature float64            `yaml:"temperature"`
        MaxTokens   int                `yaml:"max_tokens"`
        NewlineKey  string             `yaml:"newline_key,omitempty"`
        HistoryBackKey string          `yaml:"history_back_key,omitempty"`
        HistoryForwardKey string       `yaml:"history_forward_key,omitempty"`
        Profiles    map[string]Profile `yaml:"profiles,omitempty"`
        ActiveProfile string           `yaml:"active_profile,omitempty"`
}

type Profile struct {
        APIKey      string  `yaml:"api_key,omitempty"`
        Model       string  `yaml:"model,omitempty"`
        Temperature float64 `yaml:"temperature,omitempty"`
        MaxTokens   int     `yaml:"max_tokens,omitempty"`
}

var (
        defaultConfig = Config{
                Model:       "deepseek-chat",
                Temperature: 0.1,
                MaxTokens:   2048,
                Profiles:    make(map[string]Profile),
        }
)

type Manager struct {
        globalConfig  *Config
        projectConfig *Config
        mergedConfig  *Config
        globalPath    string
        projectPath   string
}

func NewManager() *Manager <span class="cov0" title="0">{
        home, _ := os.UserHomeDir()
        globalPath := filepath.Join(home, ".deecli", "config.yaml")
        projectPath := filepath.Join(".deecli", "config.yaml")

        return &amp;Manager{
                globalPath:  globalPath,
                projectPath: projectPath,
        }
}</span>

func (m *Manager) Load() error <span class="cov0" title="0">{
        m.globalConfig = &amp;Config{}
        m.projectConfig = &amp;Config{}

        // Load global config
        if err := m.loadConfigFile(m.globalPath, m.globalConfig); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load global config: %w", err)
        }</span>

        // Load project config
        <span class="cov0" title="0">if err := m.loadConfigFile(m.projectPath, m.projectConfig); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load project config: %w", err)
        }</span>

        // Merge configurations
        <span class="cov0" title="0">m.mergedConfig = m.mergeConfigs()

        // Apply environment variables (highest priority)
        m.applyEnvironmentOverrides()

        return nil</span>
}

func (m *Manager) loadConfigFile(path string, cfg *Config) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start with defaults
        <span class="cov0" title="0">*cfg = defaultConfig

        // Unmarshal YAML, overriding defaults
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid YAML in %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) mergeConfigs() *Config <span class="cov0" title="0">{
        merged := defaultConfig

        // Apply global config
        if m.globalConfig != nil </span><span class="cov0" title="0">{
                if m.globalConfig.APIKey != "" </span><span class="cov0" title="0">{
                        merged.APIKey = m.globalConfig.APIKey
                }</span>
                <span class="cov0" title="0">if m.globalConfig.Model != "" </span><span class="cov0" title="0">{
                        merged.Model = m.globalConfig.Model
                }</span>
                <span class="cov0" title="0">if m.globalConfig.Temperature != 0 </span><span class="cov0" title="0">{
                        merged.Temperature = m.globalConfig.Temperature
                }</span>
                <span class="cov0" title="0">if m.globalConfig.MaxTokens != 0 </span><span class="cov0" title="0">{
                        merged.MaxTokens = m.globalConfig.MaxTokens
                }</span>
                <span class="cov0" title="0">if len(m.globalConfig.Profiles) &gt; 0 </span><span class="cov0" title="0">{
                        merged.Profiles = m.globalConfig.Profiles
                }</span>
                <span class="cov0" title="0">if m.globalConfig.ActiveProfile != "" </span><span class="cov0" title="0">{
                        merged.ActiveProfile = m.globalConfig.ActiveProfile
                }</span>
        }

        // Apply project config (higher priority)
        <span class="cov0" title="0">if m.projectConfig != nil </span><span class="cov0" title="0">{
                if m.projectConfig.APIKey != "" </span><span class="cov0" title="0">{
                        merged.APIKey = m.projectConfig.APIKey
                }</span>
                <span class="cov0" title="0">if m.projectConfig.Model != "" </span><span class="cov0" title="0">{
                        merged.Model = m.projectConfig.Model
                }</span>
                <span class="cov0" title="0">if m.projectConfig.Temperature != 0 </span><span class="cov0" title="0">{
                        merged.Temperature = m.projectConfig.Temperature
                }</span>
                <span class="cov0" title="0">if m.projectConfig.MaxTokens != 0 </span><span class="cov0" title="0">{
                        merged.MaxTokens = m.projectConfig.MaxTokens
                }</span>
                <span class="cov0" title="0">if m.projectConfig.ActiveProfile != "" </span><span class="cov0" title="0">{
                        merged.ActiveProfile = m.projectConfig.ActiveProfile
                }</span>
                // Merge profiles
                <span class="cov0" title="0">for name, profile := range m.projectConfig.Profiles </span><span class="cov0" title="0">{
                        merged.Profiles[name] = profile
                }</span>
        }

        // Apply active profile if set
        <span class="cov0" title="0">if merged.ActiveProfile != "" </span><span class="cov0" title="0">{
                if profile, exists := merged.Profiles[merged.ActiveProfile]; exists </span><span class="cov0" title="0">{
                        if profile.APIKey != "" </span><span class="cov0" title="0">{
                                merged.APIKey = profile.APIKey
                        }</span>
                        <span class="cov0" title="0">if profile.Model != "" </span><span class="cov0" title="0">{
                                merged.Model = profile.Model
                        }</span>
                        <span class="cov0" title="0">if profile.Temperature != 0 </span><span class="cov0" title="0">{
                                merged.Temperature = profile.Temperature
                        }</span>
                        <span class="cov0" title="0">if profile.MaxTokens != 0 </span><span class="cov0" title="0">{
                                merged.MaxTokens = profile.MaxTokens
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;merged</span>
}

func (m *Manager) applyEnvironmentOverrides() <span class="cov0" title="0">{
        if apiKey := os.Getenv("DEEPSEEK_API_KEY"); apiKey != "" </span><span class="cov0" title="0">{
                m.mergedConfig.APIKey = apiKey
        }</span>
}

func (m *Manager) Get() *Config <span class="cov0" title="0">{
        if m.mergedConfig == nil </span><span class="cov0" title="0">{
                return &amp;defaultConfig
        }</span>
        <span class="cov0" title="0">return m.mergedConfig</span>
}

func (m *Manager) GetAPIKey() string <span class="cov0" title="0">{
        return m.Get().APIKey
}</span>

func (m *Manager) GetModel() string <span class="cov0" title="0">{
        return m.Get().Model
}</span>

func (m *Manager) GetTemperature() float64 <span class="cov0" title="0">{
        return m.Get().Temperature
}</span>

func (m *Manager) GetMaxTokens() int <span class="cov0" title="0">{
        return m.Get().MaxTokens
}</span>

func (m *Manager) HasAPIKey() bool <span class="cov0" title="0">{
        return m.Get().APIKey != ""
}</span>

func (m *Manager) SaveGlobal(cfg *Config) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(m.globalPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Marshal to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write file
        <span class="cov0" title="0">if err := os.WriteFile(m.globalPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) SaveProject(cfg *Config) error <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(m.projectPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Marshal to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write file
        <span class="cov0" title="0">if err := os.WriteFile(m.projectPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *Manager) InitGlobalConfig(apiKey string) error <span class="cov0" title="0">{
        cfg := &amp;Config{
                APIKey:      apiKey,
                Model:       defaultConfig.Model,
                Temperature: defaultConfig.Temperature,
                MaxTokens:   defaultConfig.MaxTokens,
                Profiles:    make(map[string]Profile),
        }

        return m.SaveGlobal(cfg)
}</span>

func (m *Manager) GlobalConfigExists() bool <span class="cov0" title="0">{
        _, err := os.Stat(m.globalPath)
        return err == nil
}</span>

func (m *Manager) ProjectConfigExists() bool <span class="cov0" title="0">{
        _, err := os.Stat(m.projectPath)
        return err == nil
}</span>

// GetNewlineKey returns the configured newline key with fallback defaults
func (m *Manager) GetNewlineKey() string <span class="cov0" title="0">{
        cfg := m.Get()
        if cfg.NewlineKey != "" </span><span class="cov0" title="0">{
                return cfg.NewlineKey
        }</span>
        // Default fallback - try common key combinations
        <span class="cov0" title="0">return "ctrl+j"</span>
}

// SetNewlineKey saves the detected newline key to global config
func (m *Manager) SetNewlineKey(key string) error <span class="cov0" title="0">{
        cfg := m.Get()
        cfg.NewlineKey = key
        return m.SaveGlobal(cfg)
}</span>

// GetHistoryBackKey returns the configured history back key with fallback defaults
func (m *Manager) GetHistoryBackKey() string <span class="cov0" title="0">{
        cfg := m.Get()
        if cfg.HistoryBackKey != "" </span><span class="cov0" title="0">{
                return cfg.HistoryBackKey
        }</span>
        // Default fallback - ctrl+p for previous (Unix/Emacs style)
        <span class="cov0" title="0">return "ctrl+p"</span>
}

// SetHistoryBackKey saves the detected history back key to global config
func (m *Manager) SetHistoryBackKey(key string) error <span class="cov0" title="0">{
        cfg := m.Get()
        cfg.HistoryBackKey = key
        return m.SaveGlobal(cfg)
}</span>

// GetHistoryForwardKey returns the configured history forward key with fallback defaults
func (m *Manager) GetHistoryForwardKey() string <span class="cov0" title="0">{
        cfg := m.Get()
        if cfg.HistoryForwardKey != "" </span><span class="cov0" title="0">{
                return cfg.HistoryForwardKey
        }</span>
        // Default fallback - ctrl+n for next (Unix/Emacs style)
        <span class="cov0" title="0">return "ctrl+n"</span>
}

// SetHistoryForwardKey saves the detected history forward key to global config
func (m *Manager) SetHistoryForwardKey(key string) error <span class="cov0" title="0">{
        cfg := m.Get()
        cfg.HistoryForwardKey = key
        return m.SaveGlobal(cfg)
}</span>

// SetKeyBinding saves a specific key binding to global config
func (m *Manager) SetKeyBinding(keyType, key string) error <span class="cov0" title="0">{
        cfg := m.Get()
        switch keyType </span>{
        case "newline":<span class="cov0" title="0">
                cfg.NewlineKey = key</span>
        case "history-back":<span class="cov0" title="0">
                cfg.HistoryBackKey = key</span>
        case "history-forward":<span class="cov0" title="0">
                cfg.HistoryForwardKey = key</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown key type: %s", keyType)</span>
        }
        <span class="cov0" title="0">return m.SaveGlobal(cfg)</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package editor

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/antenore/deecli/internal/utils"
)

// EditorFinishedMsg represents an editor closing event
type EditorFinishedMsg struct {
        Error error
}

// Config holds configuration for editor operations
type Config struct {
        // MessageProvider provides recent chat messages for instruction files
        MessageProvider func() []string
        // MessageLogger logs messages to the chat interface
        MessageLogger func(role, content string)
}

// OpenFileWithInstructions opens a file in the editor with AI-generated instruction file
func OpenFileWithInstructions(filepath string, config Config) tea.Cmd <span class="cov0" title="0">{
        // Create instruction file with context from last messages
        instructionFile := createInstructionFile(filepath, config.MessageProvider)
        
        // Auto-create directories if they don't exist
        if err := ensureDirectoryExists(filepath, config.MessageLogger); err != nil </span><span class="cov0" title="0">{
                config.MessageLogger("system", fmt.Sprintf("‚ùå Failed to create directory: %v", err))
                return nil
        }</span>
        
        // Check if this is a new file creation
        <span class="cov0" title="0">if _, err := os.Stat(filepath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create the new file with basic template
                createNewFileWithTemplate(filepath)
        }</span>
        
        // Find editor with interactive fallback
        <span class="cov0" title="0">editor := findEditor(config.MessageLogger)
        if editor == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Build command - simple approach for any editor
        <span class="cov0" title="0">var c *exec.Cmd
        // Get editor base name for switching logic
        editorParts := strings.Split(editor, "/")
        editorBase := editorParts[len(editorParts)-1]
        
        // Handle different editors with two-file opening
        switch </span>{
        case strings.Contains(editorBase, "vim") || editorBase == "nvim":<span class="cov0" title="0">
                // Vim/NVim: vertical split with target file on left, suggestions on right
                c = exec.Command(editor, "-O", filepath, instructionFile)</span>
        case editorBase == "code":<span class="cov0" title="0">
                // VSCode: open target file first, then suggestions
                c = exec.Command(editor, filepath, instructionFile)</span>
        case editorBase == "emacs":<span class="cov0" title="0">
                // Emacs: open target file first, then suggestions
                c = exec.Command(editor, filepath, instructionFile)</span>
        default:<span class="cov0" title="0">
                // Other editors: target file first, suggestions second
                c = exec.Command(editor, filepath, instructionFile)</span>
        }
        
        <span class="cov0" title="0">config.MessageLogger("system", fmt.Sprintf("üìù Opening %s with instructions in %s", filepath, editor))
        
        return tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                // Clean up instruction file
                if instructionFile != "" </span><span class="cov0" title="0">{
                        os.Remove(instructionFile)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return EditorFinishedMsg{Error: err}
                }</span>
                <span class="cov0" title="0">return EditorFinishedMsg{}</span>
        })
}

// CreateAndEditNewFile creates a new file with template and opens it for editing
func CreateAndEditNewFile(filepath string, config Config) tea.Cmd <span class="cov0" title="0">{
        // Always create instruction file for new files
        instructionFile := createInstructionFile(filepath, config.MessageProvider)
        
        // Create the new file with template
        if err := createNewFileWithTemplate(filepath); err != nil </span><span class="cov0" title="0">{
                config.MessageLogger("system", fmt.Sprintf("‚ùå Failed to create file: %v", err))
                return nil
        }</span>
        
        <span class="cov0" title="0">config.MessageLogger("system", fmt.Sprintf("‚úì Creating new file: %s", filepath))
        
        // Find editor
        editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = os.Getenv("VISUAL")
        }</span>
        <span class="cov0" title="0">if editor == "" </span><span class="cov0" title="0">{
                // Try to find a common editor
                for _, e := range []string{"nvim", "vim", "vi", "nano", "emacs"} </span><span class="cov0" title="0">{
                        if _, err := exec.LookPath(e); err == nil </span><span class="cov0" title="0">{
                                editor = e
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">if editor == "" </span><span class="cov0" title="0">{
                config.MessageLogger("system", "‚ùå No editor found. Please set $EDITOR environment variable")
                return nil
        }</span>
        
        // Build command based on editor
        <span class="cov0" title="0">var c *exec.Cmd
        if strings.Contains(editor, "vim") || editor == "nvim" </span><span class="cov0" title="0">{
                // Use vertical split for vim/nvim
                if instructionFile != "" </span><span class="cov0" title="0">{
                        c = exec.Command(editor, "-O", instructionFile, filepath)
                }</span> else<span class="cov0" title="0"> {
                        c = exec.Command(editor, filepath)
                }</span>
        } else<span class="cov0" title="0"> {
                // For other editors, just open the file
                c = exec.Command(editor, filepath)
        }</span>
        
        <span class="cov0" title="0">return tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                // Clean up instruction file
                if instructionFile != "" </span><span class="cov0" title="0">{
                        os.Remove(instructionFile)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return EditorFinishedMsg{Error: err}
                }</span>
                <span class="cov0" title="0">return EditorFinishedMsg{}</span>
        })
}

// OpenFile opens a file directly without instruction files (simple version)
func OpenFile(filepath string, config Config) tea.Cmd <span class="cov0" title="0">{
        // Parse file:line format
        file, line := parseFileAndLine(filepath)
        
        // Find editor
        editor := findEditor(config.MessageLogger)
        if editor == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var c *exec.Cmd
        editorParts := strings.Split(editor, "/")
        editorBase := editorParts[len(editorParts)-1]
        
        // Handle line number navigation
        switch </span>{
        case strings.Contains(editorBase, "vim") || editorBase == "nvim":<span class="cov0" title="0">
                if line &gt; 0 </span><span class="cov0" title="0">{
                        c = exec.Command(editor, fmt.Sprintf("+%d", line), file)
                }</span> else<span class="cov0" title="0"> {
                        c = exec.Command(editor, file)
                }</span>
        case editorBase == "code":<span class="cov0" title="0">
                if line &gt; 0 </span><span class="cov0" title="0">{
                        c = exec.Command(editor, "--goto", fmt.Sprintf("%s:%d", file, line))
                }</span> else<span class="cov0" title="0"> {
                        c = exec.Command(editor, file)
                }</span>
        case editorBase == "emacs" || editorBase == "nano":<span class="cov0" title="0">
                if line &gt; 0 </span><span class="cov0" title="0">{
                        c = exec.Command(editor, fmt.Sprintf("+%d", line), file)
                }</span> else<span class="cov0" title="0"> {
                        c = exec.Command(editor, file)
                }</span>
        default:<span class="cov0" title="0">
                // Generic fallback
                c = exec.Command(editor, file)</span>
        }
        
        <span class="cov0" title="0">config.MessageLogger("system", fmt.Sprintf("üìù Opening %s in %s", file, editor))
        
        return tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return EditorFinishedMsg{Error: err}
                }</span>
                <span class="cov0" title="0">return EditorFinishedMsg{}</span>
        })
}

// createInstructionFile creates a temporary markdown file with AI suggestions and editing tips
func createInstructionFile(filepath string, messageProvider func() []string) string <span class="cov0" title="0">{
        if messageProvider == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        // Create temp file for instructions
        <span class="cov0" title="0">tmpfile, err := os.CreateTemp("", "deecli_instructions_*.md")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">defer tmpfile.Close()
        
        instructions := ""
        instructions += fmt.Sprintf("# DeeCLI Edit Instructions for %s\n\n", filepath)
        
        // Add helpful editor shortcuts
        instructions += "## Quick Editor Tips:\n"
        instructions += "- **Vim/NVim**: Switch panes with `Ctrl+W W`, copy with `yip`, save+exit with `:wq`\n"
        instructions += "- **VSCode**: Use split view, copy suggestions, then edit\n\n"
        
        instructions += "## AI Suggestions:\n\n"
        
        // Get last few relevant messages (clean of ANSI codes)
        messages := messageProvider()
        if len(messages) &gt; 0 </span><span class="cov0" title="0">{
                // Get last AI response (usually has the suggestions)
                for i := len(messages) - 1; i &gt;= 0 &amp;&amp; i &gt;= len(messages)-5; i-- </span><span class="cov0" title="0">{
                        msg := messages[i]
                        if strings.Contains(msg, "DeeCLI:") || strings.Contains(msg, "assistant:") </span><span class="cov0" title="0">{
                                // Strip ANSI codes and clean up the content
                                cleanMsg := utils.StripANSI(msg)
                                // Trim trailing spaces from each line
                                lines := strings.Split(cleanMsg, "\n")
                                for j, line := range lines </span><span class="cov0" title="0">{
                                        lines[j] = strings.TrimRight(line, " \t")
                                }</span>
                                <span class="cov0" title="0">cleanMsg = strings.Join(lines, "\n")
                                instructions += "```\n"
                                instructions += cleanMsg + "\n"
                                instructions += "```\n\n"
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">instructions += "## Next Steps:\n"
        instructions += "1. Review the suggestions above\n"
        instructions += "2. Copy relevant code/instructions\n"
        instructions += "3. Switch to the other pane and make changes\n"
        instructions += "4. Save and exit to return to chat\n\n"
        instructions += "---\n"
        instructions += "*This instruction file will be automatically deleted when you close the editor.*\n"
        
        tmpfile.WriteString(instructions)
        return tmpfile.Name()</span>
}

// createNewFileWithTemplate creates a new file with appropriate template based on file extension
func createNewFileWithTemplate(filepath string) error <span class="cov0" title="0">{
        // Determine file type and create appropriate template
        var content string
        
        if strings.HasSuffix(filepath, ".go") </span><span class="cov0" title="0">{
                content = "package main\n\n// TODO: Implement based on AI suggestions\n"
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(filepath, ".py") </span><span class="cov0" title="0">{
                content = "#!/usr/bin/env python3\n\n# TODO: Implement based on AI suggestions\n"
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(filepath, ".js") </span><span class="cov0" title="0">{
                content = "// TODO: Implement based on AI suggestions\n"
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(filepath, ".sh") </span><span class="cov0" title="0">{
                content = "#!/bin/bash\n\n# TODO: Implement based on AI suggestions\n"
        }</span> else<span class="cov0" title="0"> {
                content = "# New file created by DeeCLI\n# TODO: Implement based on AI suggestions\n"
        }</span>
        
        // Create directory if needed
        <span class="cov0" title="0">if idx := strings.LastIndex(filepath, "/"); idx &gt; 0 </span><span class="cov0" title="0">{
                dir := filepath[:idx]
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory: %w", err)
                }</span>
        }
        
        <span class="cov0" title="0">return os.WriteFile(filepath, []byte(content), 0644)</span>
}

// findEditor attempts to find an available editor with interactive fallback
func findEditor(messageLogger func(role, content string)) string <span class="cov0" title="0">{
        // Try environment variables first
        editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = os.Getenv("VISUAL")
        }</span>
        
        // If found, verify it exists
        <span class="cov0" title="0">if editor != "" </span><span class="cov0" title="0">{
                if _, err := exec.LookPath(editor); err == nil </span><span class="cov0" title="0">{
                        return editor
                }</span>
                // Editor set but not found - inform user and fall back
                <span class="cov0" title="0">messageLogger("system", fmt.Sprintf("‚ö†Ô∏è Editor '%s' not found, searching for alternatives...", editor))</span>
        }
        
        // Try to find a common editor
        <span class="cov0" title="0">commonEditors := []string{"nvim", "vim", "vi", "nano", "emacs", "code"}
        for _, e := range commonEditors </span><span class="cov0" title="0">{
                if _, err := exec.LookPath(e); err == nil </span><span class="cov0" title="0">{
                        messageLogger("system", fmt.Sprintf("üìù Using editor: %s", e))
                        return e
                }</span>
        }
        
        // No editor found - provide helpful message
        <span class="cov0" title="0">messageLogger("system", "‚ùå No editor found. Please:")
        messageLogger("system", "   1. Install an editor: sudo apt install vim (or nvim, nano, etc.)")
        messageLogger("system", "   2. Set EDITOR environment variable: export EDITOR=vim")
        messageLogger("system", "   3. Or use /config editor &lt;editor_name&gt; (future feature)")
        return ""</span>
}

// ensureDirectoryExists creates parent directories if they don't exist
func ensureDirectoryExists(filepath string, messageLogger func(role, content string)) error <span class="cov0" title="0">{
        lastSlashIndex := strings.LastIndex(filepath, "/")
        if lastSlashIndex == -1 </span><span class="cov0" title="0">{
                // No directory component, file is in current directory
                return nil
        }</span>
        
        <span class="cov0" title="0">dir := filepath[:lastSlashIndex]
        if dir != "" &amp;&amp; dir != filepath </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
                <span class="cov0" title="0">messageLogger("system", fmt.Sprintf("üìÅ Created directory: %s", dir))</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// parseFileAndLine parses "file:line" format and returns file path and line number
func parseFileAndLine(input string) (string, int) <span class="cov0" title="0">{
        lastColon := strings.LastIndex(input, ":")
        if lastColon == -1 </span><span class="cov0" title="0">{
                return input, 0
        }</span>
        
        <span class="cov0" title="0">file := input[:lastColon]
        lineStr := input[lastColon+1:]
        
        // Try to parse line number
        var line int
        fmt.Sscanf(lineStr, "%d", &amp;line)
        
        // Check if the file part exists
        if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                return file, line
        }</span>
        
        // File doesn't exist, maybe the colon is part of the filename
        <span class="cov0" title="0">return input, 0</span>
}

</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package files

import (
        "fmt"
        "strings"
)

type FileContext struct {
        Files      []LoadedFile
        Loader     *FileLoader
        MaxContext int
}

func NewFileContext() *FileContext <span class="cov0" title="0">{
        return &amp;FileContext{
                Files:      []LoadedFile{},
                Loader:     NewFileLoader(),
                MaxContext: 50,
        }
}</span>

func (fc *FileContext) LoadFile(path string) error <span class="cov0" title="0">{
        file, err := fc.Loader.LoadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for i, f := range fc.Files </span><span class="cov0" title="0">{
                if f.Path == file.Path </span><span class="cov0" title="0">{
                        fc.Files[i] = file
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if len(fc.Files) &gt;= fc.MaxContext </span><span class="cov0" title="0">{
                return fmt.Errorf("context limit reached (%d files)", fc.MaxContext)
        }</span>

        <span class="cov0" title="0">fc.Files = append(fc.Files, file)
        return nil</span>
}

func (fc *FileContext) LoadFiles(patterns []string) error <span class="cov0" title="0">{
        files, err := fc.Loader.LoadFiles(patterns)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                exists := false
                for i, f := range fc.Files </span><span class="cov0" title="0">{
                        if f.Path == file.Path </span><span class="cov0" title="0">{
                                fc.Files[i] = file
                                exists = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        if len(fc.Files) &gt;= fc.MaxContext </span><span class="cov0" title="0">{
                                return fmt.Errorf("context limit reached (%d files)", fc.MaxContext)
                        }</span>
                        <span class="cov0" title="0">fc.Files = append(fc.Files, file)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (fc *FileContext) Clear() <span class="cov0" title="0">{
        fc.Files = []LoadedFile{}
}</span>

func (fc *FileContext) RemoveFile(path string) bool <span class="cov0" title="0">{
        absPath := path
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                for i, f := range fc.Files </span><span class="cov0" title="0">{
                        if f.RelPath == path || strings.HasSuffix(f.Path, path) </span><span class="cov0" title="0">{
                                fc.Files = append(fc.Files[:i], fc.Files[i+1:]...)
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">for i, f := range fc.Files </span><span class="cov0" title="0">{
                if f.Path == absPath </span><span class="cov0" title="0">{
                        fc.Files = append(fc.Files[:i], fc.Files[i+1:]...)
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (fc *FileContext) GetLoadedPaths() []string <span class="cov0" title="0">{
        paths := make([]string, len(fc.Files))
        for i, f := range fc.Files </span><span class="cov0" title="0">{
                paths[i] = f.RelPath
        }</span>
        <span class="cov0" title="0">return paths</span>
}

func (fc *FileContext) GetContextSize() int64 <span class="cov0" title="0">{
        var total int64
        for _, f := range fc.Files </span><span class="cov0" title="0">{
                total += f.Size
        }</span>
        <span class="cov0" title="0">return total</span>
}

func (fc *FileContext) BuildContextPrompt() string <span class="cov0" title="0">{
        if len(fc.Files) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var prompt strings.Builder
        prompt.WriteString("I have the following files loaded for context:\n\n")

        for _, file := range fc.Files </span><span class="cov0" title="0">{
                prompt.WriteString(fmt.Sprintf("=== File: %s (%s) ===\n", file.RelPath, file.Language))
                prompt.WriteString("```")
                if file.Language != "text" </span><span class="cov0" title="0">{
                        prompt.WriteString(file.Language)
                }</span>
                <span class="cov0" title="0">prompt.WriteString("\n")
                prompt.WriteString(file.Content)
                if !strings.HasSuffix(file.Content, "\n") </span><span class="cov0" title="0">{
                        prompt.WriteString("\n")
                }</span>
                <span class="cov0" title="0">prompt.WriteString("```\n\n")</span>
        }

        <span class="cov0" title="0">return prompt.String()</span>
}

func (fc *FileContext) GetInfo() string <span class="cov0" title="0">{
        return fc.Loader.GetFilesInfo(fc.Files)
}</span>

// ReloadFiles reloads files from disk, updating cached content
// If no patterns provided, reloads all currently loaded files
func (fc *FileContext) ReloadFiles(patterns []string) ([]ReloadResult, error) <span class="cov0" title="0">{
        var results []ReloadResult
        var filesToReload []string
        
        if len(patterns) == 0 </span><span class="cov0" title="0">{
                // Reload all currently loaded files
                for _, f := range fc.Files </span><span class="cov0" title="0">{
                        filesToReload = append(filesToReload, f.Path)
                }</span>
        } else<span class="cov0" title="0"> {
                // Expand patterns and filter to only loaded files
                tempFiles, err := fc.Loader.LoadFiles(patterns)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error expanding patterns: %w", err)
                }</span>
                
                <span class="cov0" title="0">for _, tempFile := range tempFiles </span><span class="cov0" title="0">{
                        // Only include if file is currently loaded
                        for _, f := range fc.Files </span><span class="cov0" title="0">{
                                if f.Path == tempFile.Path </span><span class="cov0" title="0">{
                                        filesToReload = append(filesToReload, tempFile.Path)
                                        break</span>
                                }
                        }
                }
        }
        
        <span class="cov0" title="0">if len(filesToReload) == 0 </span><span class="cov0" title="0">{
                return results, nil
        }</span>
        
        // Reload each file and track changes
        <span class="cov0" title="0">for _, path := range filesToReload </span><span class="cov0" title="0">{
                var oldFile *LoadedFile
                var oldIndex int = -1
                
                // Find existing file
                for i, f := range fc.Files </span><span class="cov0" title="0">{
                        if f.Path == path </span><span class="cov0" title="0">{
                                oldFile = &amp;f
                                oldIndex = i
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if oldFile == nil </span><span class="cov0" title="0">{
                        continue</span> // File not currently loaded
                }
                
                // Load fresh content
                <span class="cov0" title="0">newFile, err := fc.Loader.LoadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        results = append(results, ReloadResult{
                                Path: oldFile.RelPath,
                                Error: err.Error(),
                                Status: "error",
                        })
                        continue</span>
                }
                
                // Update in context
                <span class="cov0" title="0">fc.Files[oldIndex] = newFile
                
                // Track result
                status := "unchanged"
                if oldFile.Size != newFile.Size </span><span class="cov0" title="0">{
                        status = "changed"
                }</span> else<span class="cov0" title="0"> if oldFile.Content != newFile.Content </span><span class="cov0" title="0">{
                        status = "changed"
                }</span>
                
                <span class="cov0" title="0">results = append(results, ReloadResult{
                        Path: newFile.RelPath,
                        OldSize: oldFile.Size,
                        NewSize: newFile.Size,
                        Language: newFile.Language,
                        Status: status,
                })</span>
        }
        
        <span class="cov0" title="0">return results, nil</span>
}

// ReloadResult contains information about a file reload operation
type ReloadResult struct {
        Path     string
        OldSize  int64
        NewSize  int64
        Language string
        Status   string // "changed", "unchanged", "error"
        Error    string
}</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package files

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

type FileLoader struct {
        MaxFileSize int64
        MaxFiles    int
}

func NewFileLoader() *FileLoader <span class="cov0" title="0">{
        return &amp;FileLoader{
                MaxFileSize: 10 * 1024 * 1024, // 10MB default
                MaxFiles:    100,
        }
}</span>

type LoadedFile struct {
        Path     string
        RelPath  string
        Content  string
        Size     int64
        Language string
}

func (fl *FileLoader) LoadFiles(patterns []string) ([]LoadedFile, error) <span class="cov0" title="0">{
        var files []LoadedFile
        seenPaths := make(map[string]bool)

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                matches, err := fl.expandPattern(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error expanding pattern %s: %w", pattern, err)
                }</span>

                <span class="cov0" title="0">for _, path := range matches </span><span class="cov0" title="0">{
                        absPath, err := filepath.Abs(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if seenPaths[absPath] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">seenPaths[absPath] = true

                        if len(files) &gt;= fl.MaxFiles </span><span class="cov0" title="0">{
                                return files, fmt.Errorf("maximum file limit (%d) reached", fl.MaxFiles)
                        }</span>

                        <span class="cov0" title="0">file, err := fl.loadSingleFile(absPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error loading %s: %w", path, err)
                        }</span>

                        <span class="cov0" title="0">files = append(files, file)</span>
                }
        }

        <span class="cov0" title="0">return files, nil</span>
}

func (fl *FileLoader) LoadFile(path string) (LoadedFile, error) <span class="cov0" title="0">{
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("error resolving path: %w", err)
        }</span>

        <span class="cov0" title="0">return fl.loadSingleFile(absPath)</span>
}

func (fl *FileLoader) loadSingleFile(absPath string) (LoadedFile, error) <span class="cov0" title="0">{
        info, err := os.Stat(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("file not found: %w", err)
        }</span>

        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("path is a directory, not a file")
        }</span>

        <span class="cov0" title="0">if info.Size() &gt; fl.MaxFileSize </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("file too large: %d bytes (max: %d)", info.Size(), fl.MaxFileSize)
        }</span>

        <span class="cov0" title="0">if fl.isBinaryFile(absPath) </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("binary file detected, skipping")
        }</span>

        <span class="cov0" title="0">file, err := os.Open(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("error opening file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return LoadedFile{}, fmt.Errorf("error reading file: %w", err)
        }</span>

        <span class="cov0" title="0">relPath, err := filepath.Rel(".", absPath)
        if err != nil || relPath == "" </span><span class="cov0" title="0">{
                // Fallback to just the filename if Rel fails
                relPath = filepath.Base(absPath)
        }</span>

        <span class="cov0" title="0">return LoadedFile{
                Path:     absPath,
                RelPath:  relPath,
                Content:  string(content),
                Size:     info.Size(),
                Language: fl.detectLanguage(absPath),
        }, nil</span>
}

func (fl *FileLoader) expandPattern(pattern string) ([]string, error) <span class="cov0" title="0">{
        if strings.Contains(pattern, "**") </span><span class="cov0" title="0">{
                return fl.expandDoubleStarPattern(pattern)
        }</span>

        <span class="cov0" title="0">matches, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(matches) == 0 &amp;&amp; !strings.ContainsAny(pattern, "*?[") </span><span class="cov0" title="0">{
                if _, err := os.Stat(pattern); err == nil </span><span class="cov0" title="0">{
                        return []string{pattern}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("no files matching pattern: %s", pattern)</span>
        }

        <span class="cov0" title="0">var files []string
        for _, match := range matches </span><span class="cov0" title="0">{
                info, err := os.Stat(match)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, match)
                }</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

func (fl *FileLoader) expandDoubleStarPattern(pattern string) ([]string, error) <span class="cov0" title="0">{
        parts := strings.Split(pattern, "**")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ** pattern: %s", pattern)
        }</span>

        <span class="cov0" title="0">baseDir := strings.TrimSuffix(parts[0], string(filepath.Separator))
        if baseDir == "" </span><span class="cov0" title="0">{
                baseDir = "."
        }</span>

        <span class="cov0" title="0">suffix := strings.TrimPrefix(parts[1], string(filepath.Separator))

        var matches []string
        err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        if strings.HasPrefix(info.Name(), ".") &amp;&amp; info.Name() != "." </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">relPath, _ := filepath.Rel(baseDir, path)
                matched, _ := filepath.Match(suffix, filepath.Base(path))
                if matched || strings.HasSuffix(relPath, suffix) </span><span class="cov0" title="0">{
                        matches = append(matches, path)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return matches, nil</span>
}

func (fl *FileLoader) isBinaryFile(path string) bool <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">defer file.Close()

        buf := make([]byte, 512)
        n, err := file.Read(buf)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                if buf[i] == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (fl *FileLoader) detectLanguage(path string) string <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(path))
        
        languageMap := map[string]string{
                ".go":     "go",
                ".js":     "javascript",
                ".jsx":    "javascript",
                ".ts":     "typescript",
                ".tsx":    "typescript",
                ".py":     "python",
                ".rb":     "ruby",
                ".java":   "java",
                ".c":      "c",
                ".cpp":    "cpp",
                ".cc":     "cpp",
                ".cxx":    "cpp",
                ".h":      "c",
                ".hpp":    "cpp",
                ".cs":     "csharp",
                ".php":    "php",
                ".swift":  "swift",
                ".kt":     "kotlin",
                ".rs":     "rust",
                ".sh":     "bash",
                ".bash":   "bash",
                ".zsh":    "zsh",
                ".fish":   "fish",
                ".ps1":    "powershell",
                ".r":      "r",
                ".R":      "r",
                ".scala":  "scala",
                ".clj":    "clojure",
                ".cljs":   "clojure",
                ".ex":     "elixir",
                ".exs":    "elixir",
                ".erl":    "erlang",
                ".hrl":    "erlang",
                ".lua":    "lua",
                ".pl":     "perl",
                ".pm":     "perl",
                ".vim":    "vim",
                ".sql":    "sql",
                ".html":   "html",
                ".htm":    "html",
                ".xml":    "xml",
                ".css":    "css",
                ".scss":   "scss",
                ".sass":   "sass",
                ".less":   "less",
                ".json":   "json",
                ".yaml":   "yaml",
                ".yml":    "yaml",
                ".toml":   "toml",
                ".ini":    "ini",
                ".cfg":    "ini",
                ".conf":   "conf",
                ".md":     "markdown",
                ".rst":    "rst",
                ".tex":    "latex",
                ".dart":   "dart",
                ".zig":    "zig",
                ".nim":    "nim",
                ".v":      "v",
                ".jl":     "julia",
                ".ml":     "ocaml",
                ".mli":    "ocaml",
                ".fs":     "fsharp",
                ".fsx":    "fsharp",
                ".fsi":    "fsharp",
                ".elm":    "elm",
                ".purs":   "purescript",
                ".hs":     "haskell",
                ".lhs":    "haskell",
                ".vue":    "vue",
                ".svelte": "svelte",
        }

        if lang, ok := languageMap[ext]; ok </span><span class="cov0" title="0">{
                return lang
        }</span>

        <span class="cov0" title="0">if base := filepath.Base(path); base == "Makefile" || base == "makefile" </span><span class="cov0" title="0">{
                return "makefile"
        }</span>
        <span class="cov0" title="0">if base := filepath.Base(path); base == "Dockerfile" </span><span class="cov0" title="0">{
                return "dockerfile"
        }</span>

        <span class="cov0" title="0">return "text"</span>
}

func (fl *FileLoader) GetFilesInfo(files []LoadedFile) string <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return "No files loaded"
        }</span>

        <span class="cov0" title="0">var info strings.Builder
        
        // Header with file count
        if len(files) == 1 </span><span class="cov0" title="0">{
                info.WriteString("Loaded 1 file:\n\n")
        }</span> else<span class="cov0" title="0"> {
                info.WriteString(fmt.Sprintf("Loaded %d files:\n\n", len(files)))
        }</span>
        
        <span class="cov0" title="0">totalSize := int64(0)
        for i, f := range files </span><span class="cov0" title="0">{
                // Get file type icon
                icon := fl.getFileTypeIcon(f.Language)
                
                // Format file size in human-readable format
                sizeStr := fl.formatFileSize(f.Size)
                
                // Enhanced file info with icon and better formatting
                info.WriteString(fmt.Sprintf("  %s %s\n", icon, f.RelPath))
                info.WriteString(fmt.Sprintf("    %s ‚Ä¢ %s\n", f.Language, sizeStr))
                
                if i &lt; len(files)-1 </span><span class="cov0" title="0">{
                        info.WriteString("\n")
                }</span>
                
                <span class="cov0" title="0">totalSize += f.Size</span>
        }
        
        // Footer with total context size
        <span class="cov0" title="0">totalSizeStr := fl.formatFileSize(totalSize)
        info.WriteString(fmt.Sprintf("\nTotal context: %s", totalSizeStr))
        
        return info.String()</span>
}

// getFileTypeIcon returns an appropriate icon for the file type
func (fl *FileLoader) getFileTypeIcon(language string) string <span class="cov0" title="0">{
        iconMap := map[string]string{
                "go":         "üêπ",
                "javascript": "üü®",
                "typescript": "üî∑",
                "python":     "üêç",
                "rust":       "ü¶Ä",
                "java":       "‚òï",
                "c":          "‚ö°",
                "cpp":        "‚ö°",
                "html":       "üåê",
                "css":        "üé®",
                "json":       "üìã",
                "yaml":       "üìù",
                "markdown":   "üìñ",
                "sql":        "üóÉÔ∏è",
                "dockerfile": "üê≥",
                "makefile":   "üî®",
                "bash":       "üñ•Ô∏è",
                "text":       "üìÑ",
        }
        
        if icon, ok := iconMap[language]; ok </span><span class="cov0" title="0">{
                return icon
        }</span>
        <span class="cov0" title="0">return "üìÑ"</span> // default file icon
}

// formatFileSize formats bytes in human-readable format
func (fl *FileLoader) formatFileSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d bytes", bytes)
        }</span>
        
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        
        <span class="cov0" title="0">units := []string{"KB", "MB", "GB", "TB"}
        return fmt.Sprintf("%.1f %s", float64(bytes)/float64(div), units[exp])</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package history

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// Entry represents a single history entry
type Entry struct {
        Command   string    `json:"command"`
        Timestamp time.Time `json:"timestamp"`
}

// Manager handles project-specific history persistence
type Manager struct {
        projectDir  string
        historyFile string
        maxEntries  int
}

// NewManager creates a new history manager for the current project
func NewManager() (*Manager, error) <span class="cov0" title="0">{
        // Get current working directory as project root
        projectDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        // Create .deecli directory if it doesn't exist
        <span class="cov0" title="0">deecliDir := filepath.Join(projectDir, ".deecli")
        if err := os.MkdirAll(deecliDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create .deecli directory: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Manager{
                projectDir:  projectDir,
                historyFile: filepath.Join(deecliDir, "history.jsonl"),
                maxEntries:  1000, // Keep last 1000 entries
        }, nil</span>
}

// Load reads history from the project-specific file
func (m *Manager) Load() ([]string, error) <span class="cov0" title="0">{
        // Check if history file exists
        if _, err := os.Stat(m.historyFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return []string{}, nil // No history yet
        }</span>

        <span class="cov0" title="0">file, err := os.Open(m.historyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open history file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var commands []string
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                var entry Entry
                if err := json.Unmarshal(scanner.Bytes(), &amp;entry); err != nil </span><span class="cov0" title="0">{
                        // Skip malformed lines
                        continue</span>
                }
                <span class="cov0" title="0">commands = append(commands, entry.Command)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read history file: %w", err)
        }</span>

        <span class="cov0" title="0">return commands, nil</span>
}

// Add appends a new command to history
func (m *Manager) Add(command string) error <span class="cov0" title="0">{
        // Don't save empty commands or duplicates of the last command
        if command == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check last entry to avoid consecutive duplicates
        <span class="cov0" title="0">lastCommand, _ := m.GetLast()
        if lastCommand == command </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Open file in append mode
        <span class="cov0" title="0">file, err := os.OpenFile(m.historyFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open history file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        entry := Entry{
                Command:   command,
                Timestamp: time.Now(),
        }

        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal history entry: %w", err)
        }</span>

        <span class="cov0" title="0">if _, err := file.Write(append(data, '\n')); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write history entry: %w", err)
        }</span>

        // Trim history if it's too long
        <span class="cov0" title="0">return m.trimHistory()</span>
}

// GetLast returns the last command in history
func (m *Manager) GetLast() (string, error) <span class="cov0" title="0">{
        commands, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(commands) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return commands[len(commands)-1], nil</span>
}

// trimHistory keeps only the last maxEntries in the file
func (m *Manager) trimHistory() error <span class="cov0" title="0">{
        commands, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(commands) &lt;= m.maxEntries </span><span class="cov0" title="0">{
                return nil // No trimming needed
        }</span>

        // Keep only the last maxEntries
        <span class="cov0" title="0">commands = commands[len(commands)-m.maxEntries:]

        // Rewrite the file
        file, err := os.Create(m.historyFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create history file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        for _, cmd := range commands </span><span class="cov0" title="0">{
                entry := Entry{
                        Command:   cmd,
                        Timestamp: time.Now(), // We lose original timestamps during trim
                }
                data, err := json.Marshal(entry)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">file.Write(append(data, '\n'))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Clear removes all history
func (m *Manager) Clear() error <span class="cov0" title="0">{
        return os.Remove(m.historyFile)
}</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sessions

import (
        "fmt"
        "strings"

        "github.com/antenore/deecli/internal/api"
)

// LoaderDependencies contains the dependencies needed for session loading
type LoaderDependencies struct {
        SessionManager     *Manager
        CurrentSession     *Session
        Renderer           interface {
                FormatMessage(role, content string) string
                SetViewportWidth(width int, filesVisible bool)
        }
        Viewport           interface {
                SetContent(content string)
                GotoBottom() []string
        }
        ViewportWidth      int
        FilesWidgetVisible bool
        FormatInitialContent func() string
}

// Loader handles session loading operations
type Loader struct {
        deps *LoaderDependencies
}

// NewLoader creates a new session loader
func NewLoader(deps *LoaderDependencies) *Loader <span class="cov0" title="0">{
        return &amp;Loader{
                deps: deps,
        }
}</span>

// LoadSession loads the previous session and returns messages and apiMessages
func (l *Loader) LoadSession() ([]string, []api.Message, error) <span class="cov0" title="0">{
        if l.deps.SessionManager == nil || l.deps.CurrentSession == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no session manager available")
        }</span>

        <span class="cov0" title="0">messages, err := l.deps.SessionManager.GetSessionMessages(l.deps.CurrentSession.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to load session messages: %w", err)
        }</span>

        <span class="cov0" title="0">var displayMessages []string
        var apiMessages []api.Message

        // Initialize with formatted initial content
        if l.deps.FormatInitialContent != nil </span><span class="cov0" title="0">{
                displayMessages = append(displayMessages, l.deps.FormatInitialContent())
        }</span>

        <span class="cov0" title="0">for _, msg := range messages </span><span class="cov0" title="0">{
                // Store in API format for context (exclude system messages)
                if msg.Role != "system" </span><span class="cov0" title="0">{
                        apiMessages = append(apiMessages, api.Message{
                                Role:    msg.Role,
                                Content: msg.Content,
                        })
                }</span>

                // Update renderer with current viewport dimensions
                <span class="cov0" title="0">if l.deps.Renderer != nil </span><span class="cov0" title="0">{
                        l.deps.Renderer.SetViewportWidth(l.deps.ViewportWidth, l.deps.FilesWidgetVisible)
                }</span>

                // Use renderer to format the message
                <span class="cov0" title="0">var formattedContent string
                if l.deps.Renderer != nil </span><span class="cov0" title="0">{
                        formattedContent = l.deps.Renderer.FormatMessage(msg.Role, msg.Content)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback if renderer is not available
                        formattedContent = fmt.Sprintf("%s: %s", msg.Role, msg.Content)
                }</span>
                <span class="cov0" title="0">displayMessages = append(displayMessages, formattedContent)</span>
        }

        // Update viewport with content
        <span class="cov0" title="0">if l.deps.Viewport != nil </span><span class="cov0" title="0">{
                fullContent := strings.Join(displayMessages, "\n\n")
                l.deps.Viewport.SetContent(fullContent)
                l.deps.Viewport.GotoBottom()
        }</span>

        <span class="cov0" title="0">return displayMessages, apiMessages, nil</span>
}</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sessions

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

type Manager struct {
        db *sql.DB
        dbPath string
}

type Message struct {
        ID        int64
        SessionID int64
        Role      string
        Content   string
        Timestamp time.Time
}

type Session struct {
        ID        int64
        CreatedAt time.Time
        UpdatedAt time.Time
}

func NewManager() (*Manager, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">dbDir := filepath.Join(home, ".deecli")
        if err := os.MkdirAll(dbDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create db directory: %w", err)
        }</span>

        <span class="cov0" title="0">dbPath := filepath.Join(dbDir, "session.db")
        
        db, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov0" title="0">m := &amp;Manager{
                db:     db,
                dbPath: dbPath,
        }

        if err := m.initSchema(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov0" title="0">return m, nil</span>
}

func (m *Manager) initSchema() error <span class="cov0" title="0">{
        schema := `
        CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (session_id) REFERENCES sessions(id)
        );

        CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
        `

        _, err := m.db.Exec(schema)
        return err
}</span>

func (m *Manager) GetCurrentSession() (*Session, error) <span class="cov0" title="0">{
        var session Session
        err := m.db.QueryRow(`
                SELECT id, created_at, updated_at 
                FROM sessions 
                ORDER BY updated_at DESC 
                LIMIT 1
        `).Scan(&amp;session.ID, &amp;session.CreatedAt, &amp;session.UpdatedAt)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return m.CreateSession()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

func (m *Manager) CreateSession() (*Session, error) <span class="cov0" title="0">{
        result, err := m.db.Exec(`
                INSERT INTO sessions (created_at, updated_at) 
                VALUES (CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Session{
                ID:        id,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }, nil</span>
}

func (m *Manager) SaveMessage(sessionID int64, role, content string) error <span class="cov0" title="0">{
        _, err := m.db.Exec(`
                INSERT INTO messages (session_id, role, content, timestamp)
                VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        `, sessionID, role, content)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = m.db.Exec(`
                UPDATE sessions 
                SET updated_at = CURRENT_TIMESTAMP 
                WHERE id = ?
        `, sessionID)

        return err</span>
}

func (m *Manager) GetSessionMessages(sessionID int64) ([]Message, error) <span class="cov0" title="0">{
        rows, err := m.db.Query(`
                SELECT id, session_id, role, content, timestamp
                FROM messages
                WHERE session_id = ?
                ORDER BY timestamp ASC
        `, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var messages []Message
        for rows.Next() </span><span class="cov0" title="0">{
                var msg Message
                err := rows.Scan(&amp;msg.ID, &amp;msg.SessionID, &amp;msg.Role, &amp;msg.Content, &amp;msg.Timestamp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">messages = append(messages, msg)</span>
        }

        <span class="cov0" title="0">return messages, rows.Err()</span>
}

func (m *Manager) HasPreviousSession() bool <span class="cov0" title="0">{
        var count int
        err := m.db.QueryRow(`
                SELECT COUNT(*) FROM sessions
        `).Scan(&amp;count)
        
        return err == nil &amp;&amp; count &gt; 0
}</span>

func (m *Manager) Close() error <span class="cov0" title="0">{
        if m.db != nil </span><span class="cov0" title="0">{
                return m.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "fmt"
        "os"
        "os/exec"
        "strconv"
        "strings"
        "syscall"
        "unsafe"
)

// winsize struct for IOCTL terminal size detection
type winsize struct {
        Row    uint16
        Col    uint16
        Xpixel uint16
        Ypixel uint16
}

// GetTerminalSize returns terminal dimensions using multiple detection methods
func GetTerminalSize() (int, int) <span class="cov0" title="0">{
        // Use this approach for reliable terminal size detection
        if width, height, err := getTerminalSizeIoctl(); err == nil </span><span class="cov0" title="0">{
                return width, height
        }</span>
        // Fallback to tput
        <span class="cov0" title="0">if width, height := getTerminalSizeTput(); width &gt; 0 &amp;&amp; height &gt; 0 </span><span class="cov0" title="0">{
                return width, height
        }</span>
        // Final fallback to environment
        <span class="cov0" title="0">width, height := getTerminalSizeEnv()
        if width &gt; 0 &amp;&amp; height &gt; 0 </span><span class="cov0" title="0">{
                return width, height
        }</span>
        <span class="cov0" title="0">return 80, 24</span> // Safe defaults
}

// getTerminalSizeIoctl tries IOCTL system call (most accurate)
func getTerminalSizeIoctl() (int, int, error) <span class="cov0" title="0">{
        ws := &amp;winsize{}
        retCode, _, _ := syscall.Syscall(syscall.SYS_IOCTL,
                uintptr(syscall.Stdin),
                uintptr(syscall.TIOCGWINSZ),
                uintptr(unsafe.Pointer(ws)))
        if int(retCode) != -1 &amp;&amp; ws.Col &gt; 0 &amp;&amp; ws.Row &gt; 0 </span><span class="cov0" title="0">{
                return int(ws.Col), int(ws.Row), nil
        }</span>
        
        <span class="cov0" title="0">return 0, 0, fmt.Errorf("ioctl failed")</span>
}

// getTerminalSizeTput tries tput command
func getTerminalSizeTput() (int, int) <span class="cov0" title="0">{
        width, height := 0, 0
        
        if cmd := exec.Command("tput", "cols"); cmd != nil </span><span class="cov0" title="0">{
                if output, err := cmd.Output(); err == nil </span><span class="cov0" title="0">{
                        if w, err := strconv.Atoi(strings.TrimSpace(string(output))); err == nil &amp;&amp; w &gt; 0 </span><span class="cov0" title="0">{
                                width = w
                        }</span>
                }
        }
        <span class="cov0" title="0">if cmd := exec.Command("tput", "lines"); cmd != nil </span><span class="cov0" title="0">{
                if output, err := cmd.Output(); err == nil </span><span class="cov0" title="0">{
                        if h, err := strconv.Atoi(strings.TrimSpace(string(output))); err == nil &amp;&amp; h &gt; 0 </span><span class="cov0" title="0">{
                                height = h
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return width, height</span>
}

// getTerminalSizeEnv tries environment variables
func getTerminalSizeEnv() (int, int) <span class="cov0" title="0">{
        width, height := 0, 0
        
        if cols := os.Getenv("COLUMNS"); cols != "" </span><span class="cov0" title="0">{
                if w, err := strconv.Atoi(cols); err == nil &amp;&amp; w &gt; 0 </span><span class="cov0" title="0">{
                        width = w
                }</span>
        }
        <span class="cov0" title="0">if lines := os.Getenv("LINES"); lines != "" </span><span class="cov0" title="0">{
                if h, err := strconv.Atoi(lines); err == nil &amp;&amp; h &gt; 0 </span><span class="cov0" title="0">{
                        height = h
                }</span>
        }

        <span class="cov0" title="0">return width, height</span>
}

// GetTextWidth calculates available text width for messages
func GetTextWidth(viewportWidth int, filesVisible bool) int <span class="cov0" title="0">{
        availableWidth := viewportWidth - 10 // Base padding
        if filesVisible </span><span class="cov0" title="0">{
                // Account for sidebar width and borders
                availableWidth = viewportWidth - 35
        }</span>
        <span class="cov0" title="0">if availableWidth &lt; 20 </span><span class="cov0" title="0">{
                availableWidth = 20 // Minimum readable width
        }</span>
        <span class="cov0" title="0">return availableWidth</span>
}</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "regexp"
)

// StripANSI strips ANSI color codes from text
func StripANSI(s string) string <span class="cov0" title="0">{
        ansiRegex := regexp.MustCompile(`\x1b\[[0-9;]*[a-zA-Z]`)
        return ansiRegex.ReplaceAllString(s, "")
}</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2025 Antenore Gatta
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "os"

        "github.com/antenore/deecli/cmd"
)

func main() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
